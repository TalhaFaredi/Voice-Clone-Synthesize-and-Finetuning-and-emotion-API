<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spanish Voice Coloner</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            padding-top: 2rem;
            padding-bottom: 2rem;
            background-color: #f8f9fa;
        }
        .form-container {
            background-color: white;
            border-radius: 10px;
            padding: 2rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
            margin-bottom: 2rem;
        }
        .audio-results {
            background-color: white;
            border-radius: 10px;
            padding: 2rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
        }
        .audio-item {
            margin-bottom: 1rem;
            padding: 1rem;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            background-color: #f8f9fa;
        }
        .loading {
            display: none;
            text-align: center;
            margin: 2rem 0;
        }
        .spinner-border {
            width: 3rem;
            height: 3rem;
        }
  
        .disabled-button {
            background-color: #cbd5e0;
            /* Tailwind gray-300 */
            color: #a0aec0;
            /* Tailwind gray-500 */
            cursor: not-allowed;
        }

        .disabled-button:hover {
            background-color: #cbd5e0;
            /* Keep same color on hover */
        }

        /* Ensure audio controls are always visible */
        audio::-webkit-media-controls-panel {
            display: flex !important;
            opacity: 1 !important;
        }

        audio::-webkit-media-controls-play-button,
        audio::-webkit-media-controls-timeline,
        audio::-webkit-media-controls-current-time-display,
        audio::-webkit-media-controls-time-remaining-display,
        audio::-webkit-media-controls-mute-button,
        audio::-webkit-media-controls-volume-slider,
        audio::-webkit-media-controls-fullscreen-button {
            display: inline-flex !important;
            /* or flex, depending on layout needs */
        }

        .disabled-button {
            background-color: #cbd5e0;
            /* Tailwind gray-300 */
            color: #a0aec0;
            /* Tailwind gray-500 */
            cursor: not-allowed;
        }

        .disabled-button:hover {
            background-color: #cbd5e0;
            /* Keep same color on hover */
        }

        /* Ensure audio controls are always visible */
        audio::-webkit-media-controls-panel {
            display: flex !important;
            opacity: 1 !important;
        }

        audio::-webkit-media-controls-play-button,
        audio::-webkit-media-controls-timeline,
        audio::-webkit-media-controls-current-time-display,
        audio::-webkit-media-controls-time-remaining-display,
        audio::-webkit-media-controls-mute-button,
        audio::-webkit-media-controls-volume-slider,
        audio::-webkit-media-controls-fullscreen-button {
            display: inline-flex !important;
            /* or flex, depending on layout needs */
        }
        body {
    padding-top: 0rem;
    padding-bottom: 2rem !important;
    background-color: #f8f9fa!important;
}


    </style>
  
</head>

<body class="bg-gray-100 min-h-screen">
    <header class="bg-indigo-600 text-white py-6 px-4 md:px-8">
        <div class="container mx-auto">
            <h1 class="text-3xl font-bold">Spanish Voice Coloner</h1>
            <p class="text-xl">Voice Emotion Manager</p>
        </div>
    </header>

    <div class="container mx-auto p-4 md:p-8">
        <!-- Tabs Navigation -->
        <div class="flex flex-wrap border-b mb-6">
            <button id="basicTabBtn" class="px-6 py-3 bg-indigo-500 text-white rounded-t-lg mr-1 flex items-center">
                <i class="fas fa-microphone mr-2"></i> Basic
            </button>
            <button id="fineTuningTabBtn" class="px-6 py-3 bg-white text-gray-700 rounded-t-lg mr-1 flex items-center">
                <i class="fas fa-cog mr-2"></i> Fine-tuning
            </button>
            <button id="emotionsTabBtn" class="px-6 py-3 bg-white text-gray-700 rounded-t-lg mr-1 flex items-center">
                <i class="fas fa-smile-beam mr-2"></i> Emotions
            </button>
            <button id="multiStyleTabBtn" class="px-6 py-3 bg-white text-gray-700 rounded-t-lg mr-1 flex items-center">
                <i class="fas fa-layer-group mr-2"></i> Multi-Style
                <span class="ml-2 text-xs bg-gray-200 text-gray-700 px-2 py-1 rounded">Future</span>
            </button>
            <button id="advancedTabBtn" class="px-6 py-3 bg-white text-gray-700 rounded-t-lg flex items-center">
                <i class="fas fa-sliders-h mr-2"></i> Advanced
                <span class="ml-2 text-xs bg-gray-200 text-gray-700 px-2 py-1 rounded">Not Needed</span>
            </button>
        </div>

        <!-- Tab Content -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-8">
            <!-- Basic Tab Content -->
            <div id="basicTabContent" class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- Left Column: Create New Voice Clone -->
                <div>
                    <h2 class="text-2xl font-bold mb-6">Create New Voice Clone</h2>

                    <div id="cloneErrorContainer"
                        class="hidden mb-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded">
                        <p id="cloneErrorMessage"></p>
                    </div>

                    <div class="mb-6">
                        <label for="cloneLanguageSelect" class="block text-gray-700 mb-2 font-bold">Select
                            Language</label>
                        <select id="cloneLanguageSelect"
                            class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400">
                            <option value="">Select a Language</option>
                            <option value="Spanish">Spanish</option>
                            <option value="English">English</option>
                            <!-- Add other languages as needed -->
                        </select>
                    </div>

                    <div class="mb-6">
                        <label class="block text-gray-700 mb-2 font-bold">Upload/Record Voice Sample</label>
                        <div class="flex space-x-2">
                            <input type="file" id="cloneAudioFileInput" accept="audio/*,video/*" style="display:none;">
                            <button id="cloneUploadBtn"
                                class="flex items-center bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded-lg">
                                <i class="fas fa-cloud-upload-alt mr-2"></i> Upload File
                            </button>
                            <button id="cloneRecordBtn"
                                class="flex items-center bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg">
                                <i class="fas fa-microphone mr-2"></i> Record
                            </button>
                        </div>
                        
                        <div id="cloneSelectedFileNameContainer" class="mt-2 text-sm text-gray-700 hidden">
                            Selected file: <span id="cloneFileNameText"></span>
                        </div>
                        <div id="cloneRecordingStatusContainer" class="mt-2 text-sm text-gray-700 hidden">
                            <span id="cloneRecordingStatusText">Recording...</span>
                        </div>
                        <audio id="cloneAudioPreview" controls class="w-full mt-2" style="display:none;"></audio>
                    </div>

                    <div class="mb-6">
                        <label for="cloneSavedVoiceSampleSelect" class="block text-gray-700 mb-2 font-bold">Select
                            Existing Sample</label>
                        <select id="cloneSavedVoiceSampleSelect"
                            class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400">
                            <option value="">Select a saved voice sample</option>
                            <!-- Options will be populated by JavaScript -->
                        </select>
                    </div>

                    <div class="mb-6">
                        <label for="cloneVoiceNameInput" class="block text-gray-700 mb-2 font-bold">Voice Name</label>
                        <input id="cloneVoiceNameInput" type="text"
                            class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400"
                            placeholder="Enter a name for this new voice profile">
                    </div>

                    <div class="mb-6">
                        <label for="cloneTextToSpeakInput" class="block text-gray-700 mb-2 font-bold">Text to
                            Speak</label>
                        <div class="relative">
                            <textarea id="cloneTextToSpeakInput"
                                class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400 h-20"
                                placeholder="Enter text to preview with the cloned voice (maximum 200 characters)"
                                maxlength="200"></textarea>
                            <div class="text-right text-sm text-gray-500 mt-1">
                                <span id="cloneCharCount">0</span>/200 characters
                            </div>
                        </div>
                    </div>
                    <div class="flex space-x-2">
                        <button id="cloneAndPreviewBtn"
                            class="flex items-center bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg">
                            <i class="fas fa-play mr-2"></i> Clone
                        </button>
                        <button id="saveClonedVoiceProfileBtn"
                            class="flex items-center bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-lg">
                            <i class="fas fa-save mr-2"></i> Save Voice Profile
                        </button>
                    </div>
                    <div id="clonedAudioResultContainer" class="mt-4"></div>
                <h2 class="mb-4">Multi-synthesis Text to Speech</h2>
                    <div class="form-container">
            <form id="ttsForm" enctype="multipart/form-data">
                <div class="mb-3">
                    <label for="language" class="form-label">Language</label>
                    <select class="form-select" id="language" name="language" required>
                        <option value="" selected disabled>Select Language</option>
                        <option value="english">English</option>
                        <option value="spanish">Spanish</option>
                    </select>
                </div>
                
                <div class="mb-3">
                    <label for="project_name" class="form-label">Project</label>
                    <select class="form-select" id="project_name" name="project_name" required disabled>
                        <option value="" selected disabled>Select Project</option>
                    </select>
                </div>
                
                <div class="mb-3">
                    <label for="csv_file" class="form-label">CSV File (with filename and text columns)</label>
                    <input type="file" class="form-control" id="csv_file" name="csv_file" accept=".csv" required>
                    <div class="form-text">CSV must have two columns: first for filenames, second for text to synthesize.</div>
                </div>
                
                <div class="mb-3">
                    <label for="reference_audio" class="form-label">Reference Audio (required)</label>
                    <input type="file" class="form-control" id="reference_audio" name="reference_audio" accept="audio/*,video/*" required>
                    <div class="form-text">A reference audio file is required by the API for voice synthesis.</div>
                </div>
                
                <button type="submit" class="btn btn-primary">Process and Synthesize</button>
            </form>
        </div>
        
        <div class="loading" id="loadingIndicator">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Processing your request. This may take a moment...</p>
        </div>
        
        <div class="audio-results" id="results" style="display: none;">
            <h2 class="mb-4">Generated Audio Files</h2>
            <div id="audioContainer"></div>
        </div>
            <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const languageSelect = document.getElementById('language');
            const projectSelect = document.getElementById('project_name');
            const ttsForm = document.getElementById('ttsForm');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const resultsContainer = document.getElementById('results');
            const audioContainer = document.getElementById('audioContainer');
            
            // Populate projects when language changes
            languageSelect.addEventListener('change', function() {
                const language = this.value;
                projectSelect.disabled = true;
                projectSelect.innerHTML = '<option value="" selected disabled>Loading projects...</option>';
                
                fetch(`/api/get-projects?language=${language}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            projectSelect.innerHTML = '<option value="" selected disabled>Select Project</option>';
                            data.projects.forEach(project => {
                                const option = document.createElement('option');
                                option.value = project;
                                option.textContent = project;
                                projectSelect.appendChild(option);
                            });
                            projectSelect.disabled = false;
                        } else {
                            showToast('Error loading projects: ' + data.message, 'danger');
                            projectSelect.innerHTML = '<option value="" selected disabled>Error loading projects</option>';
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        showToast('Error loading projects. Please try again.', 'danger');
                        projectSelect.innerHTML = '<option value="" selected disabled>Error loading projects</option>';
                    });
            });
            
            // Handle form submission
            ttsForm.addEventListener('submit', function(e) {
                e.preventDefault();
                
                // Show loading indicator
                loadingIndicator.style.display = 'block';
                resultsContainer.style.display = 'none';
                audioContainer.innerHTML = '';
                
                const formData = new FormData(this);
                
                // Process CSV file
                fetch('/process-csv', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        processResults(data);
                    } else {
                        showToast('Error: ' + data.message, 'danger');
                        loadingIndicator.style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    showToast('Error processing CSV. Please try again.', 'danger');
                    loadingIndicator.style.display = 'none';
                });
            });
            
            // Process results from server-side sequential processing
            function processResults(data) {
                // Clear previous results
                audioContainer.innerHTML = '';
                
                // Check if we have results
                if (data.status === 'success' && data.results && data.results.length > 0) {
                    // Process each result
                    data.results.forEach(result => {
                        const audioItem = document.createElement('div');
                        audioItem.className = 'audio-item';
                        
                        // Add filename and text
                        audioItem.innerHTML = `
                            <h5>${result.filename}</h5>
                            <p><strong>Text:</strong> ${result.text}</p>
                        `;
                        
                        // Check result status
                        if (result.status === 'success') {
                            // Create audio element for successful synthesis
                            audioItem.innerHTML += `
                                <div class="audio-player">
                                    <audio controls class="mt-2 mb-2">
                                        <source src="${result.audio_path}" type="audio/wav">
                                        Your browser does not support the audio element.
                                    </audio>
                                    <div>
                                        <a href="${result.audio_path}" download="${result.filename}" class="btn btn-success btn-sm">Download</a>
                                    </div>
                                </div>
                            `;
                        } else {
                            // Show error message for failed synthesis
                            audioItem.innerHTML += `
                                <div class="alert alert-danger mt-2">
                                    Synthesis failed: ${result.error || 'Unknown error'}
                                </div>
                            `;
                        }
                        
                        audioContainer.appendChild(audioItem);
                    });
                } else {
                    // No results or error
                    audioContainer.innerHTML = `
                        <div class="alert alert-warning">
                            No results found or processing error occurred.
                        </div>
                    `;
                }
                
                // Hide loading indicator and show results
                loadingIndicator.style.display = 'none';
                resultsContainer.style.display = 'block';
            }
        });
    </script>
                </div>

                <!-- Right Column: Saved Voice Profiles -->
                <div>
                    <h2 class="text-2xl font-bold mb-6">Saved Voice Profiles</h2>
                    <div id="savedProfilesContainer" class="space-y-4 overflow-y-auto">
                        <!-- Profiles will be loaded here by JavaScript -->
                    </div>
                    <button id="openAddProfileModalBtn"
                        class="w-full mt-4 flex justify-center items-center border-2 border-dashed border-gray-300 rounded-lg p-4 text-gray-500 hover:bg-gray-50">
                        <i class="fas fa-plus mr-2"></i> Add New Voice Profile
                    </button>
                </div>
            </div>
            <!-- Fine-Tuning Tab Content -->
            <div id="fineTuningTabContent" class="hidden">
                <h2 class="text-2xl font-bold mb-6">Fine-Tune Your Voice Model</h2>
                <div class="mb-6">
                    <label for="fineTuningLanguageSelect" class="block text-gray-700 mb-2 font-bold">Select
                        Language</label>
                    <select id="fineTuningLanguageSelect"
                        class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400">
                        <option value="spanish" selected>Spanish</option>
                        <option value="english">English</option>
                    </select>
                    <small class="text-gray-500">Select the language for voice model fine-tuning</small>
                </div>
                <div id="fineTuningErrorContainer"
                    class="hidden mb-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded">
                    <p id="fineTuningErrorMessage"></p>
                </div>

                <div class="mb-6">
                    <label for="projectNameInput" class="block text-gray-700 mb-2 font-bold">Enter a project
                        name</label>
                    <input id="projectNameInput" type="text"
                        class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400"
                        placeholder="Enter a name for this fine-tuning project">
                </div>

                <div class="mb-6">
                    <label class="block text-gray-700 mb-2 font-bold">Upload/Record Voice Sample</label>
                    <div class="flex space-x-2">
                        <input type="file" id="fineTuningAudioFileInput" accept="audio/*,video/*" style="display:none;">
                        <button id="fineTuningUploadBtn"
                            class="flex items-center bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded-lg">
                            <i class="fas fa-cloud-upload-alt mr-2"></i> Upload File
                        </button>
                        <button id="fineTuningRecordBtn"
                            class="flex items-center bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg">
                            <i class="fas fa-microphone mr-2"></i> Record
                        </button>
                    </div>
                   

                    <!-- Recording interface -->
                    <div id="fineTuningRecordingInterface" class="mt-3 hidden">
                        <div class="text-center">
                            <div id="fineTuningRecordingStatus" class="mb-2">Click to start recording</div>
                            <button type="button" id="fineTuningStartStopRecording"
                                class="bg-red-500 hover:bg-red-600 text-white rounded-full w-16 h-16 flex items-center justify-center mb-2">
                                <i class="fas fa-microphone"></i>
                            </button>
                            <div id="fineTuningRecordingTime" class="mb-2">00:00</div>
                        </div>
                        <div class="flex justify-center gap-2 mt-2">
                            <button type="button" id="fineTuningCancelRecording"
                                class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50">Cancel</button>
                            <button type="button" id="fineTuningSaveRecording"
                                class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 hidden">Save
                                Recording</button>
                        </div>
                    </div>

                    <!-- Audio preview -->
                    <div id="fineTuningAudioPreview" class="mt-3 hidden">
                        <div class="bg-green-50 border border-green-200 rounded-lg p-3 flex items-center">
                            <i class="fas fa-check-circle text-green-500 mr-2"></i>
                            <div class="flex-grow">
                                <span id="fineTuningAudioFilename">Audio file ready</span>
                            </div>
                            <button type="button" id="fineTuningPlayAudio"
                                class="px-2 py-1 border border-green-500 text-green-500 rounded-lg hover:bg-green-50 mr-2">
                                <i class="fas fa-play"></i>
                            </button>
                            <button type="button" id="fineTuningRemoveAudio"
                                class="px-2 py-1 border border-red-500 text-red-500 rounded-lg hover:bg-red-50">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <audio id="fineTuningAudioPlayer" class="hidden"></audio>
                    </div>
                </div>

                <div class="flex justify-start mt-8">
                    <button id="startFineTuningBtn"
                        class="flex items-center bg-green-500 hover:bg-blue-600 text-white px-8 py-3 rounded-lg text-lg">
                        <i class="fas fa-cog mr-2"></i> Start Fine-Tuning
                    </button>
                </div>
                <!-- Progress indicator for fine-tuning -->
                <div id="fineTuningProgressContainer" class="mt-4 hidden">
                    <div class="flex items-center mb-2">
                        <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-green-500 mr-2"></div>
                        <div id="fineTuningProgressText">Processing...</div>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="fineTuningProgressBar" class="bg-green-500 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                </div>
                <!-- Status alerts for fine-tuning -->
                <div id="fineTuningStatusContainer" class="mt-3"></div>

                <!-- Add this below the "Start Fine-Tuning" button in the Fine-Tuning tab -->
                <div class="mt-8 border-t pt-6">
                    <h3 class="text-xl font-bold mb-4">Synthesize Speech</h3>

                    <!-- Language Selection -->
                    <div class="mb-6">
                        <label for="synthesisLanguageSelect" class="block text-gray-700 mb-2 font-bold">Select
                            Language</label>
                        <select id="synthesisLanguageSelect"
                            class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400">
                            <option value="spanish" selected>Spanish</option>
                            <option value="english">English</option>
                        </select>
                        <small class="text-gray-500">Select the language for speech synthesis</small>
                    </div>

                    <!-- Project Selection -->
                    <div class="mb-6">
                        <label for="projectSelect" class="block text-gray-700 mb-2 font-bold">Select Project</label>
                        <select id="projectSelect"
                            class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400">
                            <option value="" selected disabled>Choose a project</option>
                            <!-- Options will be populated by JavaScript -->
                        </select>
                    </div>

                    <!-- Text to Synthesize -->
                    <div class="mb-6">
                        <label for="synthesisText" class="block text-gray-700 mb-2 font-bold">Text to Synthesize</label>
                        <div class="relative">
                            <textarea id="synthesisText"
                                class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400 h-20"
                                placeholder="Enter text to convert to speech..." maxlength="200"></textarea>
                            <div class="text-right text-sm text-gray-500 mt-1">
                                <span id="synthesisCharCount">0</span>/200 characters
                            </div>
                        </div>
                    </div>

                    <!-- Reference Audio (Optional) -->
                    <div class="mb-6">
                        <label class="block text-gray-700 mb-2 font-bold">Reference Audio (Optional)</label>
                        <div class="flex space-x-2">
                            <input type="file" id="refAudioUpload" accept="audio/*,video/*" style="display:none;">
                            <button type="button" id="refUploadBtn"
                                class="flex items-center bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded-lg">
                                <i class="fas fa-cloud-upload-alt mr-2"></i> Upload Reference
                            </button>
                            <button type="button" id="refRecordBtn"
                                class="flex items-center bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg">
                                <i class="fas fa-microphone mr-2"></i> Record Reference
                            </button>
                        </div>
                        <small class="text-gray-500">Optional reference audio to match speaking style</small>

                        <!-- Reference Recording interface -->
                        <div id="refRecordingInterface" class="mt-3 hidden">
                            <div class="text-center">
                                <div id="refRecordingStatus" class="mb-2">Click to start recording</div>
                                <button type="button" id="refStartStopRecording"
                                    class="bg-red-500 hover:bg-red-600 text-white rounded-full w-16 h-16 flex items-center justify-center mb-2">
                                    <i class="fas fa-microphone"></i>
                                </button>
                                <div id="refRecordingTime" class="mb-2">00:00</div>
                            </div>
                            <div class="flex justify-center gap-2 mt-2">
                                <button type="button" id="refCancelRecording"
                                    class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50">Cancel</button>
                                <button type="button" id="refSaveRecording"
                                    class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 hidden">Save
                                    Recording</button>
                            </div>
                        </div>

                        <!-- Reference Audio preview -->
                        <div id="refAudioPreview" class="mt-3 hidden">
                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 flex items-center">
                                <i class="fas fa-check-circle text-blue-500 mr-2"></i>
                                <div class="flex-grow">
                                    <span id="refAudioFilename">Reference audio ready</span>
                                </div>
                                <button type="button" id="refPlayAudio"
                                    class="px-2 py-1 border border-blue-500 text-blue-500 rounded-lg hover:bg-blue-50 mr-2">
                                    <i class="fas fa-play"></i>
                                </button>
                                <button type="button" id="refRemoveAudio"
                                    class="px-2 py-1 border border-red-500 text-red-500 rounded-lg hover:bg-red-50">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            <audio id="refAudioPlayer" class="hidden"></audio>
                        </div>
                    </div>

                    <!-- Synthesize Button -->
                    <div class="flex justify-start">
                        <button type="button" id="startSynthesis"
                            class="flex items-center bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg">
                            <i class="fas fa-volume-up mr-2"></i> Synthesize Speech
                        </button>
                    </div>

                    <!-- Progress indicator for synthesis -->
                    <div id="synthesisProgressContainer" class="mt-4 hidden">
                        <div class="flex items-center mb-2">
                            <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-500 mr-2"></div>
                            <div id="synthesisProgressText">Processing...</div>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-2.5">
                            <div id="synthesisProgressBar" class="bg-blue-500 h-2.5 rounded-full" style="width: 0%">
                            </div>
                        </div>
                    </div>
                    <div id="fineTuningStatusContainer1" class="mt-3"></div>
                    <!-- Synthesis Result -->
                    <div id="synthesisResult" class="mt-4 hidden">
                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                            <h4 class="font-bold text-lg mb-2">Synthesis Result</h4>
                            <p id="synthesisTextPreview" class="mb-3 text-gray-700"></p>
                            <div class="flex items-center">
                                <button id="playSynthesis"
                                    class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 mr-2">
                                    <i class="fas fa-play mr-2"></i> Play
                                </button>
                                <button id="downloadSynthesis"
                                    class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600">
                                    <i class="fas fa-download mr-2"></i> Download
                                </button>
                            </div>
                            <audio id="synthesisPlayer" class="w-full mt-3" controls></audio>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Emotions Tab Content -->
        <div id="emotionsTabContent" class="hidden">
            <h2 class="text-2xl font-bold mb-6">Emotion Presets</h2>
            <div class="mb-6">
                <label for="EmotionlangSelect" class="block text-gray-700 mb-2 font-bold">Select Language </label>
                <select id="LanguageSelect"
                    class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400">
                    <option value="english" selected>English</option>
                    <option value="spanish">Spanish</option>
                </select>
                <small class="text-gray-500">Select the language for voice model expression</small>
            </div>
            <!-- Emotion Selection Boxes -->
            <div class="mb-6">
                <h3 class="text-xl font-bold mb-4">Select Emotion</h3>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div class="emotion-box border rounded-lg p-4 text-center cursor-pointer hover:bg-green-300 border-green-700"
                        data-emotion="Shouting">
                        <span class="text-lg">Shouting</span>
                    </div>
                    <div class="emotion-box border rounded-lg p-4 text-center cursor-pointer hover:bg-green-300 border-green-700"
                        data-emotion="Whisper">
                        <span class="text-lg">Whisper</span>
                    </div>
                    <div class="emotion-box border rounded-lg p-4 text-center cursor-pointer hover:bg-green-300 border-green-700"
                        data-emotion="Angry">
                        <span class="text-lg">Angry</span>
                    </div>
                    <div class="emotion-box border rounded-lg p-4 text-center cursor-pointer hover:bg-green-300 border-green-700"
                        data-emotion="Sad">
                        <span class="text-lg">Sad</span>
                    </div>
                    <div class="emotion-box border rounded-lg p-4 text-center cursor-pointer hover:bg-green-300 border-green-700"
                        data-emotion="Surprised">
                        <span class="text-lg">Surprised</span>
                    </div>
                    <div class="emotion-box border rounded-lg p-4 text-center cursor-pointer hover:bg-green-300 border-green-700"
                        data-emotion="Regular">
                        <span class="text-lg">Regular</span>
                    </div>
                </div>
            </div>

            <!-- Audio Upload/Record Section -->
            <div class="mb-6">
                <h3 class="text-xl font-bold mb-4">Upload/Record Audio</h3>
                <div class="flex space-x-2">
                    <input type="file" id="emotionAudioFileInput" accept="audio/*,video/*" style="display:none;">
                    <button id="emotionUploadBtn"
                        class="flex items-center bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded-lg">
                        <i class="fas fa-cloud-upload-alt mr-2"></i> Upload Audio
                    </button>
                    <button id="emotionRecordBtn"
                        class="flex items-center bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg">
                        <i class="fas fa-microphone mr-2"></i> Record
                    </button>
                </div>
                

                <div id="emotionSelectedFileNameContainer" class="mt-2 text-sm text-gray-700 hidden">
                    Selected file: <span id="emotionFileNameText"></span>
                </div>
                <div id="emotionRecordingStatusContainer" class="mt-2 text-sm text-gray-700 hidden">
                    <span id="emotionRecordingStatusText">Recording...</span>
                </div>
                <audio id="emotionAudioPreview" controls class="w-full mt-2" style="display:none;"></audio>
            </div>

            <!-- Text Area with Character Limit -->
            <div class="mb-6">
                <h3 class="text-xl font-bold mb-4">Text to Clone</h3>
                <div class="relative">
                    <textarea id="emotionTextArea"
                        class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400 h-20"
                        placeholder="Enter text to clone (minimum 25 and maximum 250 characters)" minlength="25" ,
                        maxlength="250"></textarea>
                    <div class="text-right text-sm text-gray-500 mt-1">
                        <span id="emotionCharCount">0</span>/250 characters
                    </div>
                </div>

            </div>
            <div class="flex space-x-2">

                <button id="cloneEmotionBtn"
                    class="flex items-center bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-lg">
                    <i class="fas fa-clone mr-2"></i> Clone Emotion
                </button>
                <div class="ml-4">
                    <button id="clearButton" class="flex items-center bg-red-500 text-white px-6 py-2 rounded-lg">Clear
                        Text</button>
                </div>
            </div>
            <script>
                // Get references to the elements
                const textArea = document.getElementById('emotionTextArea');
                const charCount = document.getElementById('emotionCharCount');
                const clearButton = document.getElementById('clearButton');

                // Update character count when text changes
                textArea.addEventListener('input', function () {
                    charCount.textContent = this.value.length;
                });

                // Clear the text area when the button is clicked
                clearButton.addEventListener('click', function () {
                    textArea.value = '';
                    charCount.textContent = '0';
                });
            </script>
            <!-- Clone Emotion Button -->
            <div class="mb-6" id="resultDiv">

            </div>
        </div>
        <!-- Multi-Style Tab Content (Future) -->
        <div id="multiStyleTabContent" class="hidden">
            <div class="text-center py-12">
                <div class="inline-block rounded-full bg-indigo-100 p-6 mb-6">
                    <i class="fas fa-clock text-5xl text-indigo-500"></i>
                </div>
                <h2 class="text-2xl font-bold mb-2">Coming Soon: Multi-Style Voices</h2>
                <p class="text-gray-600 max-w-lg mx-auto mb-8">
                    The Multi-Style feature will allow one voice to express multiple styles simultaneously (e.g., happy
                    + formal + dramatic). This advanced capability is planned for a future version of the Voice Coloner.
                </p>
            </div>
        </div>

        <!-- Advanced Tab Content (Not Needed) -->
        <div id="advancedTabContent" class="hidden">
            <div class="text-center py-12">
                <div class="inline-block rounded-full bg-gray-100 p-6 mb-6">
                    <i class="fas fa-tools text-5xl text-gray-400"></i>
                </div>
                <h2 class="text-2xl font-bold mb-2">Advanced Settings</h2>
                <p class="text-gray-600 max-w-lg mx-auto mb-8">
                    The Advanced Tab is currently not implemented as per requirements. It may be included in future
                    versions to offer fine-grained control over voice synthesis parameters if needed.
                </p>
            </div>
        </div>
        </div>
        
    </div>
    </div>

    <!-- Unified Add/Edit Profile Modal -->
    <div id="profileModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md mx-4">
            <div class="flex justify-between items-center border-b px-6 py-4">
                <h3 id="modalTitle" class="text-xl font-bold text-gray-800">Add New Voice Profile</h3>
                <button id="closeModalBtn" class="text-gray-500 hover:text-gray-700">
                    <i class="fas fa-times"></i>
                </button>
            </div>

            <div class="px-6 py-4 max-h-[70vh] overflow-y-auto">
                <div id="modalErrorContainer"
                    class="hidden mb-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded">
                    <p id="modalErrorMessage"></p>
                </div>

                <form id="profileForm">
                    <input type="hidden" id="profileIdInput">
                    <div class="mb-4">
                        <label for="modalVoiceName" class="block text-gray-700 mb-2">Voice Name</label>
                        <input type="text" id="modalVoiceName"
                            class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400"
                            placeholder="Enter a name for this voice profile" required>
                        <p id="modalVoiceNameError" class="text-red-500 text-sm mt-1 hidden">Voice Name is required</p>
                    </div>

                    <div class="mb-4">
                        <label for="modalLanguage" class="block text-gray-700 mb-2">Language</label>
                        <select id="modalLanguage"
                            class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400"
                            required>
                            <option value="">Select a Language</option>
                            <option value="Spanish">Spanish</option>
                            <option value="English">English</option>
                        </select>
                        <p id="modalLanguageError" class="text-red-500 text-sm mt-1 hidden">Please select a language</p>
                    </div>

                    <div class="mb-4">
                        <label class="block text-gray-700 mb-2">Upload Voice Sample</label>
                        <div class="flex space-x-2">
                            <input type="file" id="modalAudioFileInput" accept=".mp3,.wav,.webm" style="display:none;">
                            <button type="button" id="modalUploadBtn"
                                class="flex items-center bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded-lg">
                                <i class="fas fa-cloud-upload-alt mr-2"></i> Upload Audio
                            </button>
                            <button type="button" id="modalRecordBtn"
                                class="flex items-center bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg">
                                <i class="fas fa-microphone mr-2"></i> Record
                            </button>
                        </div>
                        <p class="text-sm text-gray-600 mt-2">Accepted formats: MP3, WAV, WEBM. (Required for new
                            profiles, optional if editing and not changing audio)</p>

                        <div id="modalSelectedFileNameContainer" class="mt-2 text-sm text-gray-700 hidden">
                            Selected file: <span id="modalFileNameText"></span>
                        </div>
                        <div id="modalRecordingStatusContainer" class="mt-2 text-sm text-gray-700 hidden">
                            <span id="modalRecordingStatusText">Recording...</span>
                        </div>
                        <audio id="modalAudioPreview" controls class="w-full mt-2" style="display:none;"></audio>
                        <p id="modalAudioError" class="text-red-500 text-sm mt-1 hidden">Audio is required for new
                            profiles.</p>
                    </div>

                    <div class="mb-4">
                        <label for="modalLastModifiedDate" class="block text-gray-700 mb-2">Last Modified Date
                            (Optional)</label>
                        <input type="date" id="modalLastModifiedDate"
                            class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400">
                        <p class="text-sm text-gray-600 mt-1">If not selected, current date will be used for new
                            profiles. For edits, original date is kept if unchanged.</p>
                        <!-- Error Message -->
                        <p id="modalLastModifiedDateError" class="text-red-500 text-sm mt-1 hidden">Please select a
                            valid date.</p>
                    </div>
                </form>
            </div>

            <div class="border-t px-6 py-4 flex justify-end space-x-2">
                <button id="cancelModalBtn" type="button"
                    class="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded-lg">Cancel</button>
                <button id="submitModalBtn" type="button"
                    class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg flex items-center">
                    <i class="fas fa-save mr-2"></i> Save Profile
                </button>
            </div>
        </div>
    </div>

    <footer class="py-6 text-center text-gray-600 mt-6">
        <p class="mb-1">Spanish Voice Coloner - Voice Emotion Manager</p>
        <p class="text-sm">&copy; 2024-2025. A system for voice profile management.</p>
    </footer>

    <script>
        // --- Global Variables & Constants ---
        const API_BASE_URL = "."; // Assuming Flask runs on the same domain
        let cloneRecordedAudioBlob = null;
        let selectedCloneAudioFile = null;
        let selectedProfileAudioPathForCloning = null;

        let modalRecordedAudioBlob = null;
        let modalSelectedAudioFile = null;
        let currentEditProfileData = null; // To store data of profile being edited

        let cloneMediaRecorder, cloneAudioChunks = [], isCloneRecording = false;
        let modalMediaRecorder, modalAudioChunks = [], isModalRecording = false;

        const emotionSettings = {
            happy: 0.0, sad: 0.0, angry: 0.0, surprise: 0.0,
            fear: 0.0, disgust: 0.0, neutral: 1.0, calm: 0.0
        };
        const emotionPresets = {
            "Neutral": { happy: 0, sad: 0, angry: 0, surprise: 0, fear: 0, disgust: 0, neutral: 1, calm: 0 },
            "Happy": { happy: 1, sad: 0, angry: 0, surprise: 0.2, fear: 0, disgust: 0, neutral: 0, calm: 0.1 },
            "Sad": { happy: 0, sad: 1, angry: 0, surprise: 0, fear: 0.1, disgust: 0, neutral: 0, calm: 0.2 },
            "Angry": { happy: 0, sad: 0.1, angry: 1, surprise: 0.1, fear: 0.2, disgust: 0.3, neutral: 0, calm: 0 },
            "Surprised": { happy: 0.1, sad: 0, angry: 0, surprise: 1, fear: 0.3, disgust: 0, neutral: 0, calm: 0 },
            "Fearful": { happy: 0, sad: 0.1, angry: 0, surprise: 0.3, fear: 1, disgust: 0.1, neutral: 0, calm: 0 },
            "Disgusted": { happy: 0, sad: 0.2, angry: 0.2, surprise: 0, fear: 0.1, disgust: 1, neutral: 0, calm: 0 },
            "Calm": { happy: 0.1, sad: 0, angry: 0, surprise: 0, fear: 0, disgust: 0, neutral: 0.3, calm: 1 }
        };

        // --- DOM Elements ---
        // Basic Tab - Cloning
        const cloneLanguageSelect = document.getElementById("cloneLanguageSelect");
        const cloneAudioFileInput = document.getElementById("cloneAudioFileInput");
        const cloneUploadBtn = document.getElementById("cloneUploadBtn");
        const cloneRecordBtn = document.getElementById("cloneRecordBtn");
        const cloneAudioPreview = document.getElementById("cloneAudioPreview");
        const cloneSelectedFileNameContainer = document.getElementById("cloneSelectedFileNameContainer");
        const cloneFileNameText = document.getElementById("cloneFileNameText");
        const cloneRecordingStatusContainer = document.getElementById("cloneRecordingStatusContainer");
        const cloneRecordingStatusText = document.getElementById("cloneRecordingStatusText");
        const cloneSavedVoiceSampleSelect = document.getElementById("cloneSavedVoiceSampleSelect");
        const cloneVoiceNameInput = document.getElementById("cloneVoiceNameInput");
        const cloneTextToSpeakInput = document.getElementById("cloneTextToSpeakInput");
        const cloneAndPreviewBtn = document.getElementById("cloneAndPreviewBtn");
        const saveClonedVoiceProfileBtn = document.getElementById("saveClonedVoiceProfileBtn");
        const cloneErrorContainer = document.getElementById("cloneErrorContainer");
        const cloneErrorMessage = document.getElementById("cloneErrorMessage");

        // Basic Tab - Saved Profiles
        const savedProfilesContainer = document.getElementById("savedProfilesContainer");
        const openAddProfileModalBtn = document.getElementById("openAddProfileModalBtn");

        // Modal Elements
        const profileModal = document.getElementById("profileModal");
        const modalTitle = document.getElementById("modalTitle");
        const closeModalBtn = document.getElementById("closeModalBtn");
        const cancelModalBtn = document.getElementById("cancelModalBtn");
        const submitModalBtn = document.getElementById("submitModalBtn");
        const profileForm = document.getElementById("profileForm");
        const profileIdInput = document.getElementById("profileIdInput");
        const modalVoiceName = document.getElementById("modalVoiceName");
        const modalLanguage = document.getElementById("modalLanguage");
        const modalAudioFileInput = document.getElementById("modalAudioFileInput");
        const modalUploadBtn = document.getElementById("modalUploadBtn");
        const modalRecordBtn = document.getElementById("modalRecordBtn");
        const modalAudioPreview = document.getElementById("modalAudioPreview");
        const modalSelectedFileNameContainer = document.getElementById("modalSelectedFileNameContainer");
        const modalFileNameText = document.getElementById("modalFileNameText");
        const modalRecordingStatusContainer = document.getElementById("modalRecordingStatusContainer");
        const modalRecordingStatusText = document.getElementById("modalRecordingStatusText");
        const modalLastModifiedDate = document.getElementById("modalLastModifiedDate");
        const modalLastModifiedDateError = document.getElementById("modalLastModifiedDateError");

        // Set min attribute to today's date so user can't pick earlier via calendar
        const today = new Date();
        const modalErrorContainer = document.getElementById("modalErrorContainer");
        const modalErrorMessage = document.getElementById("modalErrorMessage");
        const modalVoiceNameError = document.getElementById("modalVoiceNameError");
        const modalLanguageError = document.getElementById("modalLanguageError");
        const modalAudioError = document.getElementById("modalAudioError");

        // Emotions Tab
        const emotionProfileSelect = document.getElementById("emotionProfileSelect");
        const emotionPresetButtonsContainer = document.getElementById("emotionPresetButtonsContainer");
        const currentEmotionPresetName = document.getElementById("currentEmotionPresetName");
        const emotionSlidersContainer = document.getElementById("emotionSlidersContainer");
        const resetEmotionsBtn = document.getElementById("resetEmotionsBtn");
        const saveEmotionPresetBtn = document.getElementById("saveEmotionPresetBtn");
        const emotionJsonOutput = document.getElementById("emotionJsonOutput");
        const emotionPreviewText = document.getElementById("emotionPreviewText");
        const playWithEmotionsBtn = document.getElementById("playWithEmotionsBtn");
        const emotionPreviewAudio = document.getElementById("emotionPreviewAudio");

        // --- Helper Functions ---
        function showCloneError(message) {
            cloneErrorMessage.textContent = message;
            cloneErrorContainer.classList.remove("hidden");
        }
        function clearCloneError() {
            cloneErrorContainer.classList.add("hidden");
        }
        function showModalError(message) {
            modalErrorMessage.textContent = message;
            modalErrorContainer.classList.remove("hidden");
        }
        function clearModalError() {
            modalErrorContainer.classList.add("hidden");
            modalVoiceNameError.classList.add("hidden");
            modalLanguageError.classList.add("hidden");
            modalAudioError.classList.add("hidden");
        }

        // --- Tab Switching Logic ---
        // const tabs = ["basic", "emotions", "multiStyle", "advanced"];
        const tabs = ["basic", "fineTuning", "emotions", "multiStyle", "advanced"];
        const tabBtns = tabs.map(tab => document.getElementById(`${tab}TabBtn`));
        const tabContents = tabs.map(tab => document.getElementById(`${tab}TabContent`));

        function setActiveTab(selectedTab) {
            tabBtns.forEach((btn, index) => {
                const content = tabContents[index];
                if (tabs[index] === selectedTab) {
                    btn.classList.remove("bg-white", "text-gray-700");
                    btn.classList.add("bg-indigo-500", "text-white");
                    content.classList.remove("hidden");
                } else {
                    btn.classList.remove("bg-indigo-500", "text-white");
                    btn.classList.add("bg-white", "text-gray-700");
                    content.classList.add("hidden");
                }
            });
        }
        tabBtns.forEach((btn, index) => {
            btn.addEventListener("click", () => setActiveTab(tabs[index]));
        });

        // --- Basic Tab: Cloning Section Logic ---
        function updateCloneAudioSourceControls() {
            const isFileSelected = !!selectedCloneAudioFile;
            const isRecordingPresent = !!cloneRecordedAudioBlob;
            const isProfileSelected = !!cloneSavedVoiceSampleSelect.value;

            cloneUploadBtn.disabled = isProfileSelected || isRecordingPresent;
            cloneRecordBtn.disabled = isProfileSelected || isFileSelected;
            cloneSavedVoiceSampleSelect.disabled = isFileSelected || isRecordingPresent;

            [cloneUploadBtn, cloneRecordBtn].forEach(btn => {
                if (btn.disabled) btn.classList.add("disabled-button");
                else btn.classList.remove("disabled-button");
            });
            if (cloneSavedVoiceSampleSelect.disabled) cloneSavedVoiceSampleSelect.classList.add("opacity-50", "cursor-not-allowed");
            else cloneSavedVoiceSampleSelect.classList.remove("opacity-50", "cursor-not-allowed");
        }

        cloneUploadBtn.addEventListener("click", () => cloneAudioFileInput.click());

        cloneAudioFileInput.addEventListener("change", (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const allowedTypes = [
                // Audio types
                "audio/mpeg",   // MP3
                "audio/wav",
                "audio/webm",
                "audio/mp4",
                
                // Video types
                "video/mp4",
                "video/webm",
                "video/ogg",
                "video/quicktime", // .mov
                "video/x-msvideo", // .avi
                "video/x-matroska" // .mkv
            ];

            if (!allowedTypes.includes(file.type)) {
                showCloneError("Invalid file type. Please upload an audio or video file.");
                cloneAudioFileInput.value = ""; // Clear the invalid file
                return;
            }
            //if (!["audio/mpeg", "audio/wav", "audio/webm"].includes(file.type)) {
               // showCloneError("Invalid file type. Please upload MP3, WAV, or WEBM.");
                //cloneAudioFileInput.value = ""; // Clear the invalid file
                //return;
           // }
            clearCloneError();

            selectedCloneAudioFile = file;
            cloneRecordedAudioBlob = null;
            cloneSavedVoiceSampleSelect.value = "";
            selectedProfileAudioPathForCloning = null;

            cloneAudioPreview.src = URL.createObjectURL(file);
            cloneAudioPreview.style.display = "block";
            cloneFileNameText.textContent = file.name;
            cloneSelectedFileNameContainer.classList.remove("hidden");
            cloneRecordingStatusContainer.classList.add("hidden");
            updateCloneAudioSourceControls();
        });

        cloneRecordBtn.addEventListener("click", async () => {
            if (!isCloneRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    cloneMediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
                    cloneAudioChunks = [];

                    cloneMediaRecorder.ondataavailable = e => cloneAudioChunks.push(e.data);
                    cloneMediaRecorder.onstop = () => {
                        cloneRecordedAudioBlob = new Blob(cloneAudioChunks, { type: "audio/webm" });
                        selectedCloneAudioFile = null;
                        cloneSavedVoiceSampleSelect.value = "";
                        selectedProfileAudioPathForCloning = null;

                        cloneAudioPreview.src = URL.createObjectURL(cloneRecordedAudioBlob);
                        cloneAudioPreview.style.display = "block";
                        cloneRecordingStatusText.textContent = "Recording complete.";
                        cloneSelectedFileNameContainer.classList.add("hidden");
                        stream.getTracks().forEach(track => track.stop());
                        updateCloneAudioSourceControls();
                    };

                    cloneMediaRecorder.start();
                    cloneRecordBtn.innerHTML = '<i class="fas fa-stop mr-2"></i> Stop Recording';
                    cloneRecordBtn.classList.add("bg-yellow-500", "hover:bg-yellow-600");
                    cloneRecordBtn.classList.remove("bg-red-500", "hover:bg-red-600");
                    cloneRecordingStatusText.textContent = "Recording...";
                    cloneRecordingStatusContainer.classList.remove("hidden");
                    cloneSelectedFileNameContainer.classList.add("hidden");
                    isCloneRecording = true;
                    clearCloneError();
                } catch (err) {
                    showCloneError("Error accessing microphone: " + err.message);
                    console.error("Microphone error:", err);
                }
            } else {
                cloneMediaRecorder.stop();
                cloneRecordBtn.innerHTML = '<i class="fas fa-microphone mr-2"></i> Record';
                cloneRecordBtn.classList.remove("bg-yellow-500", "hover:bg-yellow-600");
                cloneRecordBtn.classList.add("bg-red-500", "hover:bg-red-600");
                isCloneRecording = false;
            }
            updateCloneAudioSourceControls();
        });

        cloneSavedVoiceSampleSelect.addEventListener("change", async function () {
            if (this.value) {
                selectedProfileAudioPathForCloning = this.value;
                selectedCloneAudioFile = null;
                cloneRecordedAudioBlob = null;
                cloneAudioFileInput.value = ""; // Clear file input

                cloneAudioPreview.src = `${API_BASE_URL}/static/${this.value.replace(/\\/g, "/")}`;
                cloneAudioPreview.style.display = "block";
                cloneSelectedFileNameContainer.classList.add("hidden");
                cloneRecordingStatusContainer.classList.add("hidden");
                clearCloneError();
            } else {
                selectedProfileAudioPathForCloning = null;
                // Keep cloneAudioPreview if it was from upload/record, or clear if desired
                // For now, let it be, user can clear by choosing another source or re-uploading
            }
            updateCloneAudioSourceControls();
        });

        // cloneAndPreviewBtn.addEventListener("click", () => {
        //     alert("Clone & Preview functionality requires backend integration and is not yet fully implemented in this frontend example.");
        // });

        saveClonedVoiceProfileBtn.addEventListener("click", async () => {
            clearCloneError();
            const lang = cloneLanguageSelect.value;
            const name = cloneVoiceNameInput.value.trim();

            if (!lang) { showCloneError("Please select a language for the new clone."); return; }
            if (!name) { showCloneError("Please enter a voice name for the new clone."); return; }

            let audioToSave = null;
            let audioFileName = "recorded_clone.webm";

            if (selectedCloneAudioFile) {
                audioToSave = selectedCloneAudioFile;
            } else if (cloneRecordedAudioBlob) {
                audioToSave = new File([cloneRecordedAudioBlob], audioFileName, { type: "audio/webm" });
            } else if (selectedProfileAudioPathForCloning) {
                try {
                    saveClonedVoiceProfileBtn.disabled = true;
                    saveClonedVoiceProfileBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Saving...';
                    const response = await fetch(`${API_BASE_URL}/static/${selectedProfileAudioPathForCloning.replace(/\\/g, "/")}`);
                    if (!response.ok) throw new Error(`Failed to fetch existing audio: ${response.statusText}`);
                    const blob = await response.blob();
                    const originalFileName = selectedProfileAudioPathForCloning.split(/[\\/]/).pop() || "existing_sample.webm";
                    audioToSave = new File([blob], originalFileName, { type: blob.type });
                    saveClonedVoiceProfileBtn.innerHTML = '<i class="fas fa-save mr-2"></i> Save Cloned Voice Profile';
                    saveClonedVoiceProfileBtn.disabled = false;
                } catch (err) {
                    showCloneError(`Error fetching existing audio for cloning: ${err.message}`);
                    saveClonedVoiceProfileBtn.innerHTML = '<i class="fas fa-save mr-2"></i> Save Cloned Voice Profile';
                    saveClonedVoiceProfileBtn.disabled = false;
                    return;
                }
            }

            if (!audioToSave) {
                showCloneError("Please provide an audio source (upload, record, or select existing) for the new clone.");
                return;
            }

            const formData = new FormData();
            formData.append("voiceName", name);
            formData.append("language", lang);
            formData.append("audio", audioToSave);
            // The backend /add-profile should handle created_at automatically

            saveClonedVoiceProfileBtn.disabled = true;
            saveClonedVoiceProfileBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Saving...';

            try {
                const response = await fetch(`${API_BASE_URL}/add-profile`, {
                    method: "POST",
                    body: formData,
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.error || "Server error");

                alert("Cloned voice profile saved successfully!");
                cloneLanguageSelect.value = "";
                cloneVoiceNameInput.value = "";
                cloneAudioFileInput.value = "";
                cloneAudioPreview.style.display = "none";
                cloneAudioPreview.src = "";
                cloneSelectedFileNameContainer.classList.add("hidden");
                cloneRecordingStatusContainer.classList.add("hidden");
                cloneSavedVoiceSampleSelect.value = "";
                selectedCloneAudioFile = null;
                cloneRecordedAudioBlob = null;
                selectedProfileAudioPathForCloning = null;
                updateCloneAudioSourceControls();
                loadProfiles(); // Refresh saved profiles list
            } catch (err) {
                showCloneError(`Failed to save cloned profile: ${err.message}`);
            } finally {
                saveClonedVoiceProfileBtn.disabled = false;
                saveClonedVoiceProfileBtn.innerHTML = '<i class="fas fa-save mr-2"></i> Save Cloned Voice Profile';
            }
        });

        // --- Basic Tab: Saved Profiles Logic ---
        // Final solution for the Voice Profile Application with DOM initialization fixes

        // This solution addresses the specific DOM initialization errors shown in the console

        // 1. Ensure all DOM elements are properly initialized before use
        document.addEventListener("DOMContentLoaded", function () {
            // Initialize all DOM element references
            initializeDOMReferences();

            // Set up the application
            setActiveTab("basic");
            loadProfiles();

            // Only call these functions if their required elements exist
            if (typeof renderEmotionSliders === 'function' && emotionSlidersContainer) {
                renderEmotionSliders();
            }

            if (typeof populatePresetButtons === 'function' && emotionPresetButtonsContainer) {
                populatePresetButtons();
            }

            if (typeof loadEmotionPreset === 'function') {
                loadEmotionPreset("Neutral");
            }

            if (typeof updateCloneAudioSourceControls === 'function') {
                updateCloneAudioSourceControls();
            }
        });

        // 2. Function to initialize all DOM references and add proper error handling
        function initializeDOMReferences() {
            // Basic Tab - Saved Profiles
            window.savedProfilesContainer = document.getElementById("savedProfilesContainer");
            window.cloneSavedVoiceSampleSelect = document.getElementById("cloneSavedVoiceSampleSelect");
            window.emotionProfileSelect = document.getElementById("emotionProfileSelect");

            // Emotions Tab
            window.emotionSlidersContainer = document.getElementById("emotionSlidersContainer");
            window.emotionPresetButtonsContainer = document.getElementById("emotionPresetButtonsContainer");

            // Log missing elements to help with debugging
            if (!savedProfilesContainer) console.warn("savedProfilesContainer element not found");
            if (!cloneSavedVoiceSampleSelect) console.warn("cloneSavedVoiceSampleSelect element not found");
            if (!emotionProfileSelect) console.warn("emotionProfileSelect element not found");
            if (!emotionSlidersContainer) console.warn("emotionSlidersContainer element not found");
            if (!emotionPresetButtonsContainer) console.warn("emotionPresetButtonsContainer element not found");

            // Add more element references as needed
        }

        // 3. Fixed loadProfiles function with proper null checks
        async function loadProfiles() {
            try {
                // Make sure savedProfilesContainer exists before using it
                if (!savedProfilesContainer) {
                    console.error("savedProfilesContainer element not found");
                    return;
                }

                savedProfilesContainer.innerHTML = '<div class="text-center py-4 text-gray-500"><i class="fas fa-spinner fa-spin mr-2"></i> Loading profiles...</div>';

                console.log("Fetching profiles from:", `${API_BASE_URL}/api/profiles`);

                const response = await fetch(`${API_BASE_URL}/api/profiles`);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("API Error response:", errorText);
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                const profiles = await response.json();
                console.log("Profiles loaded:", profiles);

                // Only manipulate DOM elements if they exist
                if (savedProfilesContainer) {
                    savedProfilesContainer.innerHTML = "";
                }

                if (cloneSavedVoiceSampleSelect) {
                    cloneSavedVoiceSampleSelect.innerHTML = '<option value="">Select a saved voice sample</option>';
                }

                if (emotionProfileSelect) {
                    emotionProfileSelect.innerHTML = '<option value="">Select a profile...</option>';
                }

                if (profiles.length === 0 && savedProfilesContainer) {
                    savedProfilesContainer.innerHTML = '<div class="text-center py-4 text-gray-500">No voice profiles saved yet. Add one using the button below.</div>';
                    return;
                }

                profiles.forEach(profile => {
                    const audioUrl = `${API_BASE_URL}/static/${profile.audio_path.replace(/\\/g, "/")}`;

                    // Only proceed if savedProfilesContainer exists
                    if (savedProfilesContainer) {
                        const profileCard = document.createElement("div");
                        profileCard.className = "border rounded-lg p-4 bg-white shadow";
                        profileCard.innerHTML = `
                            <div class="flex justify-between items-center mb-2">
                                <h3 class="text-lg font-semibold text-indigo-700">${profile.voice_name}</h3>
                                <div class="flex space-x-2">
                                    <button title="Edit" onclick="openModalForEdit(${profile.id})" class="text-blue-500 hover:text-blue-700"><i class="fas fa-edit"></i></button>
                                    <button title="Delete" onclick="confirmDeleteProfile(${profile.id}, \`${profile.voice_name}\`)" class="text-red-500 hover:text-red-700"><i class="fas fa-trash"></i></button>
                                </div>
                            </div>
                            <p class="text-sm text-gray-600">Language: ${profile.language}</p>
                            <p class="text-xs text-gray-500 mb-2">Last Modified: ${new Date(profile.created_at).toLocaleString()}</p>
                            <audio controls class="w-full mt-2" src="${audioUrl}">
                                Your browser does not support the audio element.
                            </audio>
                        `;
                        savedProfilesContainer.appendChild(profileCard);
                    }

                    // Only proceed if cloneSavedVoiceSampleSelect exists
                    if (cloneSavedVoiceSampleSelect) {
                        const optionClone = document.createElement("option");
                        optionClone.value = profile.audio_path;
                        optionClone.textContent = `${profile.voice_name} (${profile.language})`;
                        optionClone.dataset.profileId = profile.id;
                        cloneSavedVoiceSampleSelect.appendChild(optionClone);
                    }

                    // Only proceed if emotionProfileSelect exists
                    if (emotionProfileSelect) {
                        const optionEmotion = document.createElement("option");
                        optionEmotion.value = profile.id;
                        optionEmotion.textContent = `${profile.voice_name} (${profile.language})`;
                        optionEmotion.dataset.audioPath = audioUrl;
                        emotionProfileSelect.appendChild(optionEmotion);
                    }
                });
            } catch (error) {
                console.error("Error loading profiles:", error);
                // Make sure savedProfilesContainer exists before setting innerHTML
                if (savedProfilesContainer) {
                    savedProfilesContainer.innerHTML = `<div class="text-center py-4 text-red-500">Error loading profiles: ${error.message}. Please check console for details.</div>`;
                }
            }
        }

        // 4. Fixed renderEmotionSliders function with proper null checks
        function renderEmotionSliders() {
            // Make sure emotionSlidersContainer exists before using it
            if (!emotionSlidersContainer) {
                console.error("emotionSlidersContainer element not found");
                return;
            }

            emotionSlidersContainer.innerHTML = "";

            // Make sure emotionSettings is defined
            if (typeof emotionSettings === 'undefined') {
                console.error("emotionSettings is not defined");
                return;
            }

            for (const emotion in emotionSettings) {
                const value = emotionSettings[emotion];
                const sliderDiv = document.createElement("div");
                sliderDiv.innerHTML = `
                    <div class="flex justify-between mb-1">
                        <label class="text-gray-700 capitalize">${emotion}</label>
                        <span id="${emotion}Value" class="text-gray-700">${value.toFixed(1)}</span>
                    </div>
                    <input type="range" id="${emotion}Slider" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" min="0" max="1" step="0.05" value="${value}">
                `;
                emotionSlidersContainer.appendChild(sliderDiv);

                const slider = document.getElementById(`${emotion}Slider`);
                if (slider) {
                    slider.addEventListener("input", (e) => {
                        emotionSettings[emotion] = parseFloat(e.target.value);
                        const valueElement = document.getElementById(`${emotion}Value`);
                        if (valueElement) {
                            valueElement.textContent = emotionSettings[emotion].toFixed(1);
                        }
                        if (typeof updateEmotionJsonOutput === 'function') {
                            updateEmotionJsonOutput();
                        }
                        const currentEmotionPresetName = document.getElementById("currentEmotionPresetName");
                        if (currentEmotionPresetName) {
                            currentEmotionPresetName.textContent = "Custom";
                        }
                    });
                }
            }

            if (typeof updateEmotionJsonOutput === 'function') {
                updateEmotionJsonOutput();
            }
        }

        // 5. Add a global error handler to catch and log any JavaScript errors
        window.addEventListener('error', function (event) {
            console.error('Global error caught:', event.error);

            // Display a user-friendly error message if the container exists
            if (typeof savedProfilesContainer !== 'undefined' && savedProfilesContainer) {
                savedProfilesContainer.innerHTML = `<div class="text-center py-4 text-red-500">
                    An error occurred: ${event.error.message}. Please check the console for details.
                </div>`;
            }

            // Prevent the error from propagating
            event.preventDefault();
        });



        // 2. Updated DOMContentLoaded event listener - simplified to match your working version
        document.addEventListener("DOMContentLoaded", () => {
            setActiveTab("basic");
            loadProfiles(); // Directly load profiles without the DB check
            renderEmotionSliders();
            populatePresetButtons();
            loadEmotionPreset("Neutral");
            updateCloneAudioSourceControls();
        });

        // 3. Add a global error handler to catch and log any JavaScript errors
        window.addEventListener('error', function (event) {
            console.error('Global error caught:', event.error);

            // Only try to display error if the container exists
            if (savedProfilesContainer) {
                savedProfilesContainer.innerHTML = `<div class="text-center py-4 text-red-500">
                        An error occurred: ${event.error.message}. Please check the console for details.
                    </div>`;
            }

            // Prevent the error from propagating
            event.preventDefault();
        });

        // 4. Add a function to confirm DOM elements exist before using them
        function confirmDeleteProfile(profileId, profileName) {
            if (confirm(`Are you sure you want to delete the profile "${profileName}"?`)) {
                deleteProfileOnServer(profileId);
            }
        }
        async function deleteProfileOnServer(profileId) {
            try {
                const response = await fetch(`${API_BASE_URL}/api/profiles/${profileId}`, { method: "DELETE" });
                if (!response.ok) {
                    const result = await response.json().catch(() => ({ error: "Failed to delete profile. Server error." }));
                    throw new Error(result.error || "Failed to delete profile.");
                }
                showToast("Profile deleted successfully.", 'success');
                loadProfiles(); // Refresh list
            } catch (error) {
                console.error("Error deleting profile:", error);
                showToast(`Error deleting profile: ${error.message}`, 'danger');
            }
        }

        // --- Unified Modal Logic ---
        function openModalForAdd() {
            profileModal.classList.remove("hidden");
            modalTitle.textContent = "Add New Voice Profile";
            submitModalBtn.innerHTML = '<i class="fas fa-save mr-2"></i> Save Profile';
            submitModalBtn.addEventListener('click', () => {
                console.log("Submit button clicked in Add Profile modal");
                handleSubmitModal(false);
            })
            resetProfileForm();
            profileIdInput.value = "";
            currentEditProfileData = null;
        }

        async function openModalForEdit(profileId) {
            resetProfileForm();
            profileIdInput.value = profileId;
            try {
                const response = await fetch(`${API_BASE_URL}/api/profiles/${profileId}`);
                if (!response.ok) throw new Error("Failed to fetch profile details.");
                currentEditProfileData = await response.json();

                modalTitle.textContent = "Edit Voice Profile";
                submitModalBtn.innerHTML = '<i class="fas fa-save mr-2"></i> Update Profile';
                submitModalBtn.onclick = () => handleSubmitModal(true);

                modalVoiceName.value = currentEditProfileData.voice_name;
                modalLanguage.value = currentEditProfileData.language;
                today.setHours(0, 0, 0, 0); // Normalize time
                modalLastModifiedDate.min = today.toISOString().split("T")[0];

                // Validate manually in case user enters a date manually (e.g., via keyboard)
                modalLastModifiedDate.addEventListener("change", function () {
                    const selectedDate = this.value ? new Date(this.value) : null;

                    if (selectedDate && selectedDate < today) {
                        modalLastModifiedDateError.classList.remove("hidden");
                        this.focus(); // Optional: refocus the field
                        return;
                    } else {
                        modalLastModifiedDateError.classList.add("hidden");
                        return true;
                    }
                });
                modalAudioPreview.src = `${API_BASE_URL}/static/${currentEditProfileData.audio_path.replace(/\\/g, "/")}`;
                modalAudioPreview.style.display = "block";
                modalAudioError.textContent = "Audio is required for new profiles. For edits, upload/record only if changing."; // Adjust message
                profileModal.classList.remove("hidden");
            } catch (error) {
                showModalError(`Error loading profile for editing: ${error.message}`);
                console.error("Edit load error:", error);
            }
        }

        function closeModal() {
            profileModal.classList.add("hidden");
            resetProfileForm();
        }

        function resetProfileForm() {
            profileForm.reset();
            profileIdInput.value = "";
            modalAudioPreview.style.display = "none";
            modalAudioPreview.src = "";
            modalSelectedFileNameContainer.classList.add("hidden");
            modalRecordingStatusContainer.classList.add("hidden");
            modalSelectedAudioFile = null;
            modalRecordedAudioBlob = null;
            currentEditProfileData = null;
            if (modalMediaRecorder && modalMediaRecorder.state === "recording") {
                modalMediaRecorder.stop();
            }
            modalRecordBtn.innerHTML = '<i class="fas fa-microphone mr-2"></i> Record';
            modalRecordBtn.classList.remove("bg-yellow-500", "hover:bg-yellow-600");
            modalRecordBtn.classList.add("bg-red-500", "hover:bg-red-600");
            isModalRecording = false;
            clearModalError();
        }

        modalUploadBtn.addEventListener("click", () => modalAudioFileInput.click());
        modalAudioFileInput.addEventListener("change", (event) => {
            const file = event.target.files[0];
            if (!file) return;
            if (!["audio/mpeg", "audio/wav", "audio/webm"].includes(file.type)) {
                modalAudioError.textContent = "Invalid file type. Please upload MP3, WAV, or WEBM.";
                modalAudioError.classList.remove("hidden");
                modalAudioFileInput.value = "";
                return;
            }
            modalAudioError.classList.add("hidden");

            modalSelectedAudioFile = file;
            modalRecordedAudioBlob = null;
            modalAudioPreview.src = URL.createObjectURL(file);
            modalAudioPreview.style.display = "block";
            modalFileNameText.textContent = file.name;
            modalSelectedFileNameContainer.classList.remove("hidden");
            modalRecordingStatusContainer.classList.add("hidden");
        });

        modalRecordBtn.addEventListener("click", async () => {
            if (!isModalRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    modalMediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
                    modalAudioChunks = [];
                    modalMediaRecorder.ondataavailable = e => modalAudioChunks.push(e.data);
                    modalMediaRecorder.onstop = () => {
                        modalRecordedAudioBlob = new Blob(modalAudioChunks, { type: "audio/webm" });
                        modalSelectedAudioFile = null;
                        modalAudioPreview.src = URL.createObjectURL(modalRecordedAudioBlob);
                        modalAudioPreview.style.display = "block";
                        modalRecordingStatusText.textContent = "Recording complete.";
                        modalSelectedFileNameContainer.classList.add("hidden");
                        stream.getTracks().forEach(track => track.stop());
                    };
                    modalMediaRecorder.start();
                    modalRecordBtn.innerHTML = '<i class="fas fa-stop mr-2"></i> Stop Recording';
                    modalRecordBtn.classList.add("bg-yellow-500", "hover:bg-yellow-600");
                    modalRecordBtn.classList.remove("bg-red-500", "hover:bg-red-600");
                    modalRecordingStatusText.textContent = "Recording...";
                    modalRecordingStatusContainer.classList.remove("hidden");
                    modalSelectedFileNameContainer.classList.add("hidden");
                    isModalRecording = true;
                    modalAudioError.classList.add("hidden");
                } catch (err) {
                    showModalError("Error accessing microphone: " + err.message);
                }
            } else {
                modalMediaRecorder.stop();
                modalRecordBtn.innerHTML = '<i class="fas fa-microphone mr-2"></i> Record';
                modalRecordBtn.classList.remove("bg-yellow-500", "hover:bg-yellow-600");
                modalRecordBtn.classList.add("bg-red-500", "hover:bg-red-600");
                isModalRecording = false;
            }
        });

        async function handleSubmitModal(isEditMode) {
            const modalLastModifiedDate = document.getElementById("modalLastModifiedDate").value;
            const formData = new FormData();

            clearModalError();
            const voiceName = modalVoiceName.value.trim();
            const language = modalLanguage.value;
            const selectedDate = modalLastModifiedDate ? new Date(modalLastModifiedDate) : null;
            const profileId = profileIdInput.value;

            let isValid = true;
            if (!voiceName) { modalVoiceNameError.classList.remove("hidden"); isValid = false; }
            if (!language) { modalLanguageError.classList.remove("hidden"); isValid = false; }

            let audioDataToSend = null;
            if (modalSelectedAudioFile) {
                audioDataToSend = modalSelectedAudioFile;
            } else if (modalRecordedAudioBlob) {
                audioDataToSend = new File([modalRecordedAudioBlob], "modal_recording.webm", { type: "audio/webm" });
            }
            if (selectedDate) {
                const todayStart = new Date(); // Current date/time
                todayStart.setHours(0, 0, 0, 0); // Normalize to midnight

                const selectedStart = new Date(selectedDate);
                selectedStart.setHours(0, 0, 0, 0); // Normalize to midnight

                if (selectedStart.getTime() !== todayStart.getTime()) {
                    console.warn("Selected date is not today:", selectedDate.toISOString());
                    modalLastModifiedDateError.classList.remove("hidden");
                    return; // Stop form submission
                } else {
                    console.log("Selected date is today:", selectedDate.toISOString());
                    modalLastModifiedDateError.classList.add("hidden");
                    const selectedDateISO = selectedDate.toISOString().split('T')[0]; // 'YYYY-MM-DD'

                    formData.append("created_at", selectedDateISO);
                }
            } else {
                modalLastModifiedDateError.classList.add("hidden");
            }

            if (!isEditMode && !audioDataToSend) {
                modalAudioError.textContent = "Audio is required for new profiles.";
                modalAudioError.classList.remove("hidden");
                isValid = false;
            }
            if (isEditMode && !audioDataToSend && !currentEditProfileData.audio_path) {
                modalAudioError.textContent = "Audio is required if not previously set.";
                modalAudioError.classList.remove("hidden");
                isValid = false;
            }

            if (!isValid) return;

            formData.append("voiceName", voiceName);
            formData.append("language", language);

            if (modalLastModifiedDate) {
                const date = new Date(modalLastModifiedDate);

                // Check if date is valid and matches YYYY-MM-DD format
                // const isValidDate = !isNaN(date.getTime()) &&
                //     /^\d{4}-\d{2}-\d{2}$/.test(modalLastModifiedDate);
                // 
                // if (isValidDate) {
                // formData.append("created_at", modalLastModifiedDate);
                // } else {
                //     console.warn("Invalid date entered:", modalLastModifiedDate);
                //     // Optionally show an error message to the user
                // }
            }
            if (audioDataToSend) formData.append("audio", audioDataToSend);

            const url = isEditMode ? `${API_BASE_URL}/api/profiles/${profileId}/edit` : `${API_BASE_URL}/add-profile`;
            const method = "POST"; // Flask routes can handle POST for update too, or use PUT for edit if backend is set up for it

            submitModalBtn.disabled = true;
            submitModalBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Saving...';

            try {
                const response = await fetch(url, { method: method, body: formData });
                const result = await response.json();
                if (!response.ok) throw new Error(result.error || "Server error");

                alert(`Profile ${isEditMode ? "updated" : "saved"} successfully!`);
                closeModal();
                loadProfiles();
            } catch (err) {
                showModalError(`Failed to ${isEditMode ? "update" : "save"} profile: ${err.message}`);
            } finally {
                submitModalBtn.disabled = false;
                submitModalBtn.innerHTML = isEditMode ?
                    '<i class="fas fa-save mr-2"></i> Update Profile' :
                    '<i class="fas fa-save mr-2"></i> Save Profile';
            }
        }

        openAddProfileModalBtn.addEventListener("click", openModalForAdd);
        closeModalBtn.addEventListener("click", closeModal);
        cancelModalBtn.addEventListener("click", closeModal);

        // --- Emotions Tab Logic ---
        function renderEmotionSliders() {
            emotionSlidersContainer.innerHTML = "";
            for (const emotion in emotionSettings) {
                const value = emotionSettings[emotion];
                const sliderDiv = document.createElement("div");
                sliderDiv.innerHTML = `
            <div class="flex justify-between mb-1">
                <label class="text-gray-700 capitalize">${emotion}</label>
                <span id="${emotion}Value" class="text-gray-700">${value.toFixed(1)}</span>
            </div>
            <input type="range" id="${emotion}Slider" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" min="0" max="1" step="0.05" value="${value}">
        `;
                emotionSlidersContainer.appendChild(sliderDiv);
                document.getElementById(`${emotion}Slider`).addEventListener("input", (e) => {
                    emotionSettings[emotion] = parseFloat(e.target.value);
                    document.getElementById(`${emotion}Value`).textContent = emotionSettings[emotion].toFixed(1);
                    updateEmotionJsonOutput();
                    currentEmotionPresetName.textContent = "Custom";
                });
            }
            updateEmotionJsonOutput();
        }

        function updateEmotionJsonOutput() {
            emotionJsonOutput.textContent = JSON.stringify(emotionSettings, null, 2);
        }

        function loadEmotionPreset(presetName) {
            if (emotionPresets[presetName]) {
                for (const emotion in emotionPresets[presetName]) {
                    emotionSettings[emotion] = emotionPresets[presetName][emotion];
                }
                renderEmotionSliders(); // Re-render to update slider values and displayed numbers
                currentEmotionPresetName.textContent = presetName;
            }
        }

        function populatePresetButtons() {
            emotionPresetButtonsContainer.innerHTML = "";
            for (const presetName in emotionPresets) {
                const button = document.createElement("button");
                button.className = "bg-white border border-gray-300 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-indigo-400";
                button.textContent = presetName;
                button.onclick = () => loadEmotionPreset(presetName);
                emotionPresetButtonsContainer.appendChild(button);
            }
        }

        resetEmotionsBtn.addEventListener("click", () => loadEmotionPreset("Neutral"));
        saveEmotionPresetBtn.addEventListener("click", () => alert("Save custom preset functionality not yet implemented."));
        playWithEmotionsBtn.addEventListener("click", () => {
            const selectedProfileOption = emotionProfileSelect.options[emotionProfileSelect.selectedIndex];
            const audioPath = selectedProfileOption ? selectedProfileOption.dataset.audioPath : null;
            const text = emotionPreviewText.value;
            if (!audioPath) {
                alert("Please select a voice profile from the dropdown above to preview emotions.");
                return;
            }
            if (!text.trim()) {
                alert("Please enter some text to speak for the emotion preview.");
                return;
            }
            console.log("Emotion Settings:", emotionSettings);
            console.log("Text to speak:", text);
            console.log("Base audio path for TTS:", audioPath);
            alert("Playing with emotions requires backend TTS integration. Check console for data.");
        });

        // --- Initializations ---
        document.addEventListener("DOMContentLoaded", () => {
            setActiveTab("basic");
            loadProfiles();
            renderEmotionSliders();
            populatePresetButtons();
            loadEmotionPreset("Neutral"); // Start with Neutral preset
            updateCloneAudioSourceControls(); // Initial state for clone audio controls
        });
        // Tab switching functionality
        function setActiveTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('[id$="TabContent"]').forEach(tab => {
                tab.classList.add("hidden");
            });

            // Show selected tab content
            const selectedTab = document.getElementById(tabName + "TabContent");
            if (selectedTab) {
                selectedTab.classList.remove("hidden");
            }

            // Update tab button styles
            document.querySelectorAll('[id$="TabBtn"]').forEach(btn => {
                btn.classList.remove("bg-indigo-500", "text-white");
                btn.classList.add("bg-white", "text-gray-700");
            });

            const activeTabBtn = document.getElementById(tabName + "TabBtn");
            if (activeTabBtn) {
                activeTabBtn.classList.remove("bg-white", "text-gray-700");
                activeTabBtn.classList.add("bg-indigo-500", "text-white");
            }
        }

        // Tab button click event listeners
        document.getElementById("basicTabBtn").addEventListener("click", () => setActiveTab("basic"));
        document.getElementById("fineTuningTabBtn").addEventListener("click", () => setActiveTab("fineTuning"));
        document.getElementById("emotionsTabBtn").addEventListener("click", () => setActiveTab("emotions"));
        document.getElementById("multiStyleTabBtn").addEventListener("click", () => setActiveTab("multiStyle"));
        document.getElementById("advancedTabBtn").addEventListener("click", () => setActiveTab("advanced"));

        // Fine-Tuning Tab JavaScript

        // Variables for Fine-Tuning Tab
        let selectedFineTuningAudioFile = null;
        let fineTuningRecordedAudioBlob = null;
        let fineTuningMediaRecorder = null;
        let fineTuningAudioChunks = [];
        let isFineTuningRecording = false;

        // DOM Elements
        const projectNameInput = document.getElementById("projectNameInput");
        const fineTuningAudioFileInput = document.getElementById("fineTuningAudioFileInput");
        const fineTuningUploadBtn = document.getElementById("fineTuningUploadBtn");
        const fineTuningRecordBtn = document.getElementById("fineTuningRecordBtn");
        const fineTuningSelectedFileNameContainer = document.getElementById("fineTuningSelectedFileNameContainer");
        const fineTuningFileNameText = document.getElementById("fineTuningFileNameText");
        const fineTuningRecordingStatusContainer = document.getElementById("fineTuningRecordingStatusContainer");
        const fineTuningRecordingStatusText = document.getElementById("fineTuningRecordingStatusText");
        const fineTuningAudioPreview = document.getElementById("fineTuningAudioPreview");
        const startFineTuningBtn = document.getElementById("startFineTuningBtn");
        const fineTuningErrorContainer = document.getElementById("fineTuningErrorContainer");
        const fineTuningErrorMessage = document.getElementById("fineTuningErrorMessage");

        // Upload button functionality
        fineTuningUploadBtn.addEventListener("click", () => {
            fineTuningAudioFileInput.click();
        });

        // File input change handler
        fineTuningAudioFileInput.addEventListener("change", (event) => {
            const file = event.target.files[0];
            if (!file) return;

            if (!["audio/mpeg", "audio/wav", "audio/webm"].includes(file.type)) {
                showFineTuningError("Invalid file type. Please upload MP3, WAV, or WEBM.");
                fineTuningAudioFileInput.value = "";
                return;
            }

            selectedFineTuningAudioFile = file;
            fineTuningRecordedAudioBlob = null;
            fineTuningAudioPreview.src = URL.createObjectURL(file);
            fineTuningAudioPreview.style.display = "block";
            fineTuningFileNameText.textContent = file.name;
            fineTuningSelectedFileNameContainer.classList.remove("hidden");
            fineTuningRecordingStatusContainer.classList.add("hidden");
            clearFineTuningError();
            fineTuningAudioFileInput.value = "";
        });

        // Record button functionality
        fineTuningRecordBtn.addEventListener("click", async () => {
            if (!isFineTuningRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    fineTuningMediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
                    fineTuningAudioChunks = [];

                    fineTuningMediaRecorder.ondataavailable = e => fineTuningAudioChunks.push(e.data);
                    fineTuningMediaRecorder.onstop = () => {
                        fineTuningRecordedAudioBlob = new Blob(fineTuningAudioChunks, { type: "audio/webm" });
                        selectedFineTuningAudioFile = null;
                        fineTuningAudioPreview.src = URL.createObjectURL(fineTuningRecordedAudioBlob);
                        fineTuningAudioPreview.style.display = "block";
                        fineTuningRecordingStatusText.textContent = "Recording complete.";
                        fineTuningSelectedFileNameContainer.classList.add("hidden");
                        stream.getTracks().forEach(track => track.stop());
                    };

                    fineTuningMediaRecorder.start();
                    fineTuningRecordBtn.innerHTML = '<i class="fas fa-stop mr-2"></i> Stop Recording';
                    fineTuningRecordBtn.classList.add("bg-yellow-500", "hover:bg-yellow-600");
                    fineTuningRecordBtn.classList.remove("bg-red-500", "hover:bg-red-600");
                    fineTuningRecordingStatusText.textContent = "Recording...";
                    fineTuningRecordingStatusContainer.classList.remove("hidden");
                    fineTuningSelectedFileNameContainer.classList.add("hidden");
                    isFineTuningRecording = true;
                    clearFineTuningError();
                } catch (err) {
                    showFineTuningError("Error accessing microphone: " + err.message);
                    console.error("Microphone error:", err);
                }
            } else {
                fineTuningMediaRecorder.stop();
                fineTuningRecordBtn.innerHTML = '<i class="fas fa-microphone mr-2"></i> Record';
                fineTuningRecordBtn.classList.remove("bg-yellow-500", "hover:bg-yellow-600");
                fineTuningRecordBtn.classList.add("bg-red-500", "hover:bg-red-600");
                isFineTuningRecording = false;
            }
        });

        // Start Fine-Tuning button functionality
        startFineTuningBtn.addEventListener("click", async () => {
            clearFineTuningError();
            const projectName = projectNameInput.value.trim();

            if (!projectName) {
                showFineTuningError("Please enter a project name for fine-tuning.");
                return;
            }

            if (!selectedFineTuningAudioFile && !fineTuningRecordedAudioBlob) {
                showFineTuningError("Please provide an audio source (upload or record) for fine-tuning.");
                return;
            }

            let audioToUse = null;
            let audioFileName = "fine_tuning_audio.webm";

            if (selectedFineTuningAudioFile) {
                audioToUse = selectedFineTuningAudioFile;
            } else if (fineTuningRecordedAudioBlob) {
                audioToUse = new File([fineTuningRecordedAudioBlob], audioFileName, { type: "audio/webm" });
            }

            if (!audioToUse) {
                showFineTuningError("Error preparing audio for fine-tuning.");
                return;
            }

            // Prepare form data for submission
            const formData = new FormData();
            formData.append("projectName", projectName);
            formData.append("audio", audioToUse);

            // Disable button and show loading state
            startFineTuningBtn.disabled = true;
            startFineTuningBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Processing...';

            try {
                // This would be replaced with actual API endpoint for fine-tuning
                const response = await fetch(`${API_BASE_URL}/fine-tune`, {
                    method: "POST",
                    body: formData,
                });

                const result = await response.json();
                if (!response.ok) throw new Error(result.error || "Server error");

                alert("Fine-tuning process started successfully!");

                // Reset form
                projectNameInput.value = "";
                fineTuningAudioFileInput.value = "";
                fineTuningAudioPreview.style.display = "none";
                fineTuningAudioPreview.src = "";
                fineTuningSelectedFileNameContainer.classList.add("hidden");
                fineTuningRecordingStatusContainer.classList.add("hidden");
                selectedFineTuningAudioFile = null;
                fineTuningRecordedAudioBlob = null;

            } catch (err) {
                showFineTuningError(`Failed to start fine-tuning: ${err.message}`);
            } finally {
                // Reset button state
                startFineTuningBtn.disabled = false;
                startFineTuningBtn.innerHTML = '<i class="fas fa-cog mr-2"></i> Start Fine-Tuning';
            }
        });

        // Helper functions
        function showFineTuningError(message) {
            fineTuningErrorMessage.textContent = message;
            fineTuningErrorContainer.classList.remove("hidden");
        }

        function clearFineTuningError() {
            // fineTuningErrorContainer.classList.add("hidden");
            fineTuningErrorMessage.textContent = "";
        }
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const cloneAndPreviewBtn = document.getElementById("cloneAndPreviewBtn");
            const cloneLanguageSelect = document.getElementById("cloneLanguageSelect");
            const cloneTextToSpeakInput = document.getElementById("cloneTextToSpeakInput");
            const cloneAudioFileInput = document.getElementById("cloneAudioFileInput");
            const cloneAudioPreview = document.getElementById("cloneAudioPreview"); // For recorded audio
            const cloneSavedVoiceSampleSelect = document.getElementById("cloneSavedVoiceSampleSelect");
            const clonedAudioResultContainer = document.getElementById("clonedAudioResultContainer");
            const cloneErrorContainer = document.getElementById("cloneErrorContainer");
            const cloneErrorMessage = document.getElementById("cloneErrorMessage");

            function displayCloneError(message) {
                if (cloneErrorMessage && cloneErrorContainer) {
                    cloneErrorMessage.textContent = message;
                    cloneErrorContainer.classList.remove("hidden");
                    // Hide after 5 seconds
                    setTimeout(() => {
                        cloneErrorContainer.classList.add("hidden");
                        cloneErrorMessage.textContent = "";
                    }, 5000);
                } else {
                    console.error("Clone error display elements not found. Message: ", message);
                    alert("Error: " + message); // Fallback alert
                }
            }

            async function handleCloneVoiceRequest() {
                if (!clonedAudioResultContainer) {
                    console.error("clonedAudioResultContainer not found");
                    alert("Result container not found. Cannot proceed.");
                    return;
                }
                clonedAudioResultContainer.innerHTML = ""; // Clear previous results
                if (cloneErrorContainer) cloneErrorContainer.classList.add("hidden"); // Clear previous errors

                const language = cloneLanguageSelect.value;
                const gen_text = cloneTextToSpeakInput.value;

                if (!language) {
                    displayCloneError("Please select a language.");
                    return;
                }
                if (!gen_text.trim()) {
                    displayCloneError("Please enter text to speak.");
                    return;
                }

                const formData = new FormData();
                formData.append("language", language);
                formData.append("gen_text", gen_text);

                let audioSourceProvided = false;
                let audioFileToUpload = null;

                // Priority 1: Uploaded file
                if (cloneAudioFileInput.files && cloneAudioFileInput.files[0]) {
                    audioFileToUpload = cloneAudioFileInput.files[0];
                    formData.append("ref_audio_file", audioFileToUpload);
                    audioSourceProvided = true;
                }
                // Priority 2: Recorded audio (check if cloneAudioPreview.src is a blob)
                else if (cloneAudioPreview.src && cloneAudioPreview.src.startsWith("blob:")) {
                    try {
                        clonedAudioResultContainer.innerHTML =
                            "<p class=\"text-gray-700\">Processing recorded audio...</p>";
                        const response = await fetch(cloneAudioPreview.src);
                        const blob = await response.blob();
                        let extension = ".webm"; // Default
                        if (blob.type.includes("wav")) extension = ".wav";
                        else if (blob.type.includes("mp3")) extension = ".mp3";
                        const recordedFile = new File([blob], `recorded_audio${extension}`, { type: blob.type });
                        formData.append("ref_audio_file", recordedFile);
                        audioSourceProvided = true;
                    } catch (error) {
                        console.error("Error fetching recorded audio blob:", error);
                        displayCloneError("Error processing recorded audio. Please try recording again.");
                        clonedAudioResultContainer.innerHTML = ""; // Clear processing message
                        return;
                    }
                }
                // Priority 3: Selected existing sample
                else if (cloneSavedVoiceSampleSelect.value) {
                    formData.append("ref_audio_path", cloneSavedVoiceSampleSelect.value);
                    audioSourceProvided = true;
                }

                if (!audioSourceProvided) {
                    displayCloneError("Please upload, record, or select a reference voice sample.");
                    return;
                }

                clonedAudioResultContainer.innerHTML =
                    "<p class=\"text-gray-700\">Cloning voice, please wait... This may take a moment.</p>";
                cloneAndPreviewBtn.disabled = true;
                cloneAndPreviewBtn.classList.add("disabled-button");


                try {
                    const response = await fetch("/api/clone-voice", {
                        method: "POST",
                        body: formData
                    });

                    clonedAudioResultContainer.innerHTML = ""; // Clear loading/processing message

                    if (response.ok) {
                        const audioBlob = await response.blob();
                        if (audioBlob.type.startsWith("audio/")) {
                            const audioUrl = URL.createObjectURL(audioBlob);
                            const audioElement = document.createElement("audio");
                            audioElement.controls = true;
                            audioElement.src = audioUrl;
                            audioElement.classList.add("w-full", "mt-2");
                            clonedAudioResultContainer.appendChild(audioElement);
                        } else {
                            const errorText = await response.text();
                            try {
                                const errorData = JSON.parse(errorText);
                                if (errorData && errorData.error) {
                                    displayCloneError(`Cloning failed: ${errorData.error} ${errorData.details || ""}`);
                                } else {
                                    displayCloneError("Cloning failed. Received an unexpected non-audio response from the server.");
                                }
                            } catch (e) {
                                displayCloneError(`Cloning failed. Server response: ${errorText.substring(0, 200)}`);
                            }
                        }
                    } else {
                        const errorText = await response.text();
                        try {
                            const errorData = JSON.parse(errorText);
                            if (errorData && errorData.error) {
                                displayCloneError(`Cloning failed: ${errorData.error} ${errorData.details || ""}`);
                            } else {
                                displayCloneError(`Cloning failed. Status: ${response.status} ${response.statusText}. Response: ${errorText.substring(0, 200)}`);
                            }
                        } catch (e) {
                            displayCloneError(`Cloning failed. Status: ${response.status} ${response.statusText}. Raw response: ${errorText.substring(0, 200)}`);
                        }
                    }
                } catch (error) {
                    console.error("Error during voice cloning:", error);
                    clonedAudioResultContainer.innerHTML = ""; // Clear loading message
                    displayCloneError("An error occurred while cloning the voice. Please check the console for details or network issues.");
                } finally {
                    cloneAndPreviewBtn.disabled = false;
                    cloneAndPreviewBtn.classList.remove("disabled-button");
                }
            }

            if (cloneAndPreviewBtn) {
                cloneAndPreviewBtn.addEventListener("click", handleCloneVoiceRequest);
            } else {
                console.error("Clone button (cloneAndPreviewBtn) not found.");
            }
        });

        // Emotions Tab JavaScript

        // Variables for audio handling
        let selectedEmotionAudioFile = null;
        let emotionRecordedAudioBlob = null;
        let emotionMediaRecorder = null;
        let emotionAudioChunks = [];
        let isEmotionRecording = false;

        // Emotion selection functionality
        document.querySelectorAll('.emotion-box').forEach(box => {
            box.addEventListener('click', function () {
                // Remove selected class from all boxes
                document.querySelectorAll('.emotion-box').forEach(b => {
                    b.classList.remove('bg-green-300', 'border-green-700');
                });

                // Add selected class to clicked box
                this.classList.add('bg-green-300', 'border-green-700');

                // Update current emotion
                const selectedEmotion = this.getAttribute('data-emotion');
                console.log(`Selected emotion: ${selectedEmotion}`);

                // Here you could update any other UI elements or variables based on the selection
            });
        });

        // Audio upload functionality
        document.getElementById('emotionUploadBtn').addEventListener('click', () => {
            document.getElementById('emotionAudioFileInput').click();
        });

        document.getElementById('emotionAudioFileInput').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const allowedTypes = [
                // Audio types
                "audio/mpeg",   // MP3
                "audio/wav",
                "audio/webm",
                "audio/mp4",
                
                // Video types
                "video/mp4",
                "video/webm",
                "video/ogg",
                "video/quicktime", // .mov
                "video/x-msvideo", // .avi
                "video/x-matroska" // .mkv
            ];

            if (!allowedTypes.includes(file.type)) {
                showCloneError("Invalid file type. Please upload an audio or video file.");
                document.getElementById('emotionAudioFileInput').value = ""; // Clear the invalid file
                return;
            }

            //if (!["audio/mpeg", "audio/wav", "audio/webm"].includes(file.type)) {
                //alert("Invalid file type. Please upload MP3, WAV, or WEBM.");
                //document.getElementById('emotionAudioFileInput').value = ""; // Clear the invalid file
                //return;
            //}

            selectedEmotionAudioFile = file;
            emotionRecordedAudioBlob = null;

            const audioPreview = document.getElementById('emotionAudioPreview');
            audioPreview.src = URL.createObjectURL(file);
            audioPreview.style.display = "block";

            document.getElementById('emotionFileNameText').textContent = file.name;
            document.getElementById('emotionSelectedFileNameContainer').classList.remove("hidden");
            document.getElementById('emotionRecordingStatusContainer').classList.add("hidden");

            updateEmotionAudioSourceControls();
        });

        // Audio recording functionality
        document.getElementById('emotionRecordBtn').addEventListener('click', async () => {
            if (!isEmotionRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    emotionMediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
                    emotionAudioChunks = [];

                    emotionMediaRecorder.ondataavailable = e => emotionAudioChunks.push(e.data);
                    emotionMediaRecorder.onstop = () => {
                        emotionRecordedAudioBlob = new Blob(emotionAudioChunks, { type: "audio/webm" });
                        selectedEmotionAudioFile = null;

                        const audioPreview = document.getElementById('emotionAudioPreview');
                        audioPreview.src = URL.createObjectURL(emotionRecordedAudioBlob);
                        audioPreview.style.display = "block";

                        document.getElementById('emotionRecordingStatusText').textContent = "Recording complete.";
                        document.getElementById('emotionSelectedFileNameContainer').classList.add("hidden");
                        stream.getTracks().forEach(track => track.stop());

                        updateEmotionAudioSourceControls();
                    };

                    emotionMediaRecorder.start();
                    const recordBtn = document.getElementById('emotionRecordBtn');
                    recordBtn.innerHTML = '<i class="fas fa-stop mr-2"></i> Stop Recording';
                    recordBtn.classList.add("bg-yellow-500", "hover:bg-yellow-600");
                    recordBtn.classList.remove("bg-red-500", "hover:bg-red-600");

                    document.getElementById('emotionRecordingStatusText').textContent = "Recording...";
                    document.getElementById('emotionRecordingStatusContainer').classList.remove("hidden");
                    document.getElementById('emotionSelectedFileNameContainer').classList.add("hidden");
                    isEmotionRecording = true;
                } catch (err) {
                    alert("Error accessing microphone: " + err.message);
                    console.error("Microphone error:", err);
                }
            } else {
                emotionMediaRecorder.stop();
                const recordBtn = document.getElementById('emotionRecordBtn');
                recordBtn.innerHTML = '<i class="fas fa-microphone mr-2"></i> Record';
                recordBtn.classList.remove("bg-yellow-500", "hover:bg-yellow-600");
                recordBtn.classList.add("bg-red-500", "hover:bg-red-600");
                isEmotionRecording = false;
            }

            updateEmotionAudioSourceControls();
        });

        // Character counter for text area
        document.getElementById('emotionTextArea').addEventListener('input', function () {
            const maxLength = 250;

            const currentLength = this.value.length;

            document.getElementById('emotionCharCount').textContent = currentLength;

            // Optional: Add visual feedback when approaching the limit
            if (currentLength >= maxLength * 0.9) {
                document.getElementById('emotionCharCount').classList.add('text-red-500');
            } else {
                document.getElementById('emotionCharCount').classList.remove('text-red-500');
            }
        });

        // Clone Emotion button functionality (placeholder)
        // document.getElementById('cloneEmotionBtn').addEventListener('click', function () {
        //     console.log("Clone Emotion button clicked");
        //     // Placeholder for future functionality
        // });
        // Clone Emotion button functionality (placeholder)
        document.getElementById('cloneEmotionBtn').addEventListener('click', function () {

            if (document.getElementById('emotionTextArea').length < 25) {
                alert("Please enter at least 25 characters of text to clone.");
                return;
            }
            console.log("Clone Emotion button clicked");
            // Placeholder for future functionality
        });

        // Helper function to update audio source controls
        function updateEmotionAudioSourceControls() {
            const isFileSelected = !!selectedEmotionAudioFile;
            const isRecordingPresent = !!emotionRecordedAudioBlob;

            const uploadBtn = document.getElementById('emotionUploadBtn');
            const recordBtn = document.getElementById('emotionRecordBtn');

            uploadBtn.disabled = isRecordingPresent;
            recordBtn.disabled = isFileSelected && !isEmotionRecording;

            [uploadBtn, recordBtn].forEach(btn => {
                if (btn.disabled) btn.classList.add("disabled-button");
                else btn.classList.remove("disabled-button");
            });
        }
        // Make sure this code runs after the page is fully loaded
        document.addEventListener('DOMContentLoaded', function () {
            // Get the text area and character count elements
            const fineTuningTextArea = document.getElementById('fineTuningTextArea');
            const fineTuningCharCount = document.getElementById('fineTuningCharCount');

            // Check if both elements exist before adding the event listener
            if (fineTuningTextArea && fineTuningCharCount) {
                // Initial count update (in case there's default text)
                fineTuningCharCount.textContent = fineTuningTextArea.value.length;

                // Add event listeners for all possible input events
                ['input', 'keyup', 'keydown', 'change', 'paste'].forEach(function (event) {
                    fineTuningTextArea.addEventListener(event, function () {
                        const currentLength = this.value.length;
                        fineTuningCharCount.textContent = currentLength;

                        // Visual feedback when approaching the limit
                        if (currentLength >= 180) { // 90% of 200
                            fineTuningCharCount.classList.add('text-red-500');
                        } else {
                            fineTuningCharCount.classList.remove('text-red-500');
                        }
                    });
                });
            } else {
                console.error("Character counter elements not found");
            }
        });
        // Character counter for Basic tab textarea
        document.addEventListener("DOMContentLoaded", function () {
            // Get the textarea and counter elements
            const cloneTextToSpeakInput = document.getElementById("cloneTextToSpeakInput");
            const cloneCharCount = document.getElementById("cloneCharCount");

            if (cloneTextToSpeakInput && cloneCharCount) {
                // Initialize character count
                cloneCharCount.textContent = cloneTextToSpeakInput.value.length;

                // Update character count on input
                cloneTextToSpeakInput.addEventListener("input", function () {
                    cloneCharCount.textContent = this.value.length;
                });
            }
        });
        // Emotion API Integration for Clone Emotion Button

        // Emotion API Integration for Clone Emotion Button

        // document.addEventListener("DOMContentLoaded", () => {
        //     // Get the Clone Emotion button in the Emotions tab
        //     const cloneEmotionBtn = document.getElementById('cloneEmotionBtn');

        //     if (cloneEmotionBtn) {
        //         cloneEmotionBtn.addEventListener('click', handleCloneEmotion);
        //     } else {
        //         console.error("Clone Emotion button not found in the DOM");
        //     }

        //     // Function to handle the Clone Emotion button click
        //     async function handleCloneEmotion() {
        //         // Get the result container for displaying output/errors
        //         const resultContainer = document.getElementById('resultDiv')
        //         //  ||
        //             // document.createElement('div'); // Fallback if container doesn't exist

        //         // Clear previous results
        //         // resultContainer.innerHTML = "";

        //         try {
        //             // 1. Get the selected emotion
        //             const selectedEmotionElement = document.querySelector('.emotion-box.bg-blue-50.border-blue-500');
        //             if (!selectedEmotionElement) {
        //                 showError("Please select an emotion first.");
        //                 return;
        //             }
        //             const emotionName = selectedEmotionElement.getAttribute('data-emotion');

        //             // 2. Get the text input
        //             const textArea = document.getElementById('emotionTextArea');
        //             if (!textArea || !textArea.value.trim()) {
        //                 showError("Please enter text to clone.");
        //                 return;
        //             }
        //             const genText = textArea.value.trim();

        //             // 3. Get the audio file (uploaded or recorded)
        //             let audioFile = null;

        //             // Check for uploaded file
        //             if (selectedEmotionAudioFile) {
        //                 audioFile = selectedEmotionAudioFile;
        //             }
        //             // Check for recorded audio
        //             else if (emotionRecordedAudioBlob) {
        //                 audioFile = new File([emotionRecordedAudioBlob], "recorded_audio.webm", { type: "audio/webm" });
        //             }

        //             if (!audioFile) {
        //                 showError("Please upload or record an audio sample.");
        //                 return;
        //             }

        //             // 4. Prepare the FormData with all required parameters
        //             const formData = new FormData();
        //             formData.append("ref_audio", audioFile);
        //             formData.append("gen_text", genText);
        //             formData.append("emotion_name", emotionName);

        //             // 5. Add the hardcoded parameters
        //             formData.append("remove_silence", true);
        //             formData.append("emotion_seed", -1);
        //             formData.append("emotion_speed", 1.0);

        //             // 6. Show loading state
        //             cloneEmotionBtn.disabled = true;
        //             cloneEmotionBtn.classList.add("disabled-button");


        //             // 7. Make the API call - FIXED: Use relative URL or proxy to avoid CORS issues
        //             // Instead of hardcoded URL, use a relative URL that can be proxied by your server
        //             const apiUrl = "http://54.91.220.174:5000/api/generate-voice"; // This will be proxied to the actual endpoint

        //             const response = await fetch(apiUrl, {
        //                 method: "POST",
        //                 body: formData
        //             });
        //             // 8. Handle the response
        //             if (response.ok) {
        //                 const audioBlob = await response.blob();
        //                 if (audioBlob.type.startsWith("audio/")) {
        //                     const audioUrl = URL.createObjectURL(audioBlob);
        //                     const audioElement = document.createElement("audio");
        //                     audioElement.controls = true;
        //                     audioElement.src = audioUrl;
        //                     audioElement.classList.add("w-full", "mt-4");
        //                     audioElement.id = 'res-audio'

        //                     resultContainer.appendChild(audioElement);

        //                     // ? Create download button
        //                     const downloadBtn = document.createElement("a");
        //                     downloadBtn.href = audioUrl;
        //                     downloadBtn.download = `${emotionName?.toLowerCase() || 'voice'}_voice.mp3`;
        //                     downloadBtn.textContent = "?? Download Voice";
        //                     downloadBtn.setAttribute("style", `
        //                     display:inline-block;
        //                     margin-top:12px;
        //                     background-color:#3b82f6;
        //                     color:white;
        //                     padding:10px 16px;
        //                     border-radius:10px;
        //                     text-decoration:none;
        //                     font-weight:bold; `);
        //                     resultContainer.appendChild(downloadBtn);
        //                 } else {
        //                     showError("Received non-audio response from the server.");
        //                 }
        //             } else {
        //                 // Handle error response
        //                 console.error("Error during emotion voice generation:",);

        //             }
        //         } catch (error) {
        //             console.error("Error during emotion voice generation:", error);
        //             showError(`An error occurred: ${error.message}`);
        //         } finally {
        //             // Re-enable the button
        //             cloneEmotionBtn.disabled = false;
        //             cloneEmotionBtn.classList.remove("disabled-button");
        //         }
        //     }

        //     // Helper function to show errors
        //     function showError(message) {
        //         const resultContainer = document.getElementById('emotionResultContainer');
        //         if (resultContainer) {
        //             resultContainer.innerHTML = `<p class="text-red-600">${message}</p>`;
        //         } else {
        //             console.error(message);
        //             alert(message); // Fallback
        //         }
        //     }
        // });
        document.addEventListener("DOMContentLoaded", () => {

            // Get the Clone Emotion button in the Emotions tab
            const cloneEmotionBtn = document.getElementById('cloneEmotionBtn');

            if (cloneEmotionBtn) {
                cloneEmotionBtn.addEventListener('click', handleCloneEmotion);

            } else {
                console.error("Clone Emotion button not found in the DOM");
            }

            // Function to handle the Clone Emotion button click
            async function handleCloneEmotion() {

                const emotionText = document.getElementById('emotionTextArea').value;

                if (emotionText.length < 25) {
                    alert("Please enter at least 25 characters of text to clone.");
                    return;
                }

                // Get the result container for displaying output/errors
                const resultContainer = document.getElementById('resultDiv')
                //  ||
                // document.createElement('div'); // Fallback if container doesn't exist

                // Clear previous results
                resultContainer.innerHTML = "";
                cloneEmotionBtn.disabled = true;
                try {
                    // 1. Get the selected emotion
                    const selectedEmotionElement = document.querySelector('.emotion-box.bg-green-300.border-green-700');
                    if (!selectedEmotionElement) {
                        showError("Please select an emotion first.");
                        return;
                    }
                    const emotionName = selectedEmotionElement.getAttribute('data-emotion');

                    // 2. Get the text input
                    const textArea = document.getElementById('emotionTextArea');
                    if (!textArea || !textArea.value.trim()) {
                        showError("Please enter text to clone.");
                        return;
                    }
                    const genText = textArea.value.trim();



                    // 3. Get the audio file (uploaded or recorded)
                    let audioFile = null;

                    // Check for uploaded file
                    if (selectedEmotionAudioFile) {
                        audioFile = selectedEmotionAudioFile;
                    }
                    // Check for recorded audio
                    else if (emotionRecordedAudioBlob) {
                        audioFile = new File([emotionRecordedAudioBlob], "recorded_audio.webm", { type: "audio/webm" });
                    }

                    if (!audioFile) {
                        showError("Please upload or record an audio sample.");
                        return;
                    }

                    // 4. Prepare the FormData with all required parameters
                    const formData = new FormData();
                    formData.append("ref_audio", audioFile);
                    formData.append("gen_text", genText);
                    formData.append("emotion_name", emotionName);

                    // Get the selected language
                    const languageSelect = document.getElementById('LanguageSelect');
                    const selectedLanguage = languageSelect ? languageSelect.value : 'english'; // Default to 'english'
                    formData.append("language", selectedLanguage);

                    // 5. Add the hardcoded parameters
                    formData.append("remove_silence", true);
                    formData.append("emotion_seed", -1);
                    formData.append("emotion_speed", 1.0);

                    // 6. Show loading state
                    cloneEmotionBtn.disabled = true;
                    cloneEmotionBtn.classList.add("disabled-button");


                    // 7. Make the API call - FIXED: Use relative URL or proxy to avoid CORS issues
                    // Instead of hardcoded URL, use a relative URL that can be proxied by your server
                    const apiUrl = "http://34.238.66.156:5000/api/generate-voice"; // This will be proxied to the actual endpoint

                    const response = await fetch(apiUrl, {
                        method: "POST",
                        body: formData
                    });
                    // 8. Handle the response
                    if (response.ok) {
                        const audioBlob = await response.blob();
                        if (audioBlob.type.startsWith("audio/")) {
                            const audioUrl = URL.createObjectURL(audioBlob);
                            const audioElement = document.createElement("audio");
                            audioElement.controls = true;
                            audioElement.src = audioUrl;
                            audioElement.classList.add("w-full", "mt-4");
                            audioElement.id = 'res-audio'

                            resultContainer.appendChild(audioElement);

                            // ? Create download button
                            const downloadBtn = document.createElement("a");
                            downloadBtn.href = audioUrl;
                            downloadBtn.download = `${emotionName?.toLowerCase() || 'voice'}_voice.mp3`;
                            downloadBtn.textContent = "Download Voice";
                            downloadBtn.setAttribute("style", `
                            display:inline-block;
                            margin-top:12px;
                            background-color:#3b82f6;
                            color:white;
                            padding:10px 16px;
                            border-radius:10px;
                            text-decoration:none;
                            font-weight:bold; `);
                            resultContainer.appendChild(downloadBtn);
                        } else {
                            showError("Received non-audio response from the server.");
                        }
                    } else {
                        // Handle error response
                        console.error("Error during emotion voice generation:",);

                    }
                } catch (error) {
                    console.error("Error during emotion voice generation:", error);
                    showError(`An error occurred: ${error.message}`);
                } finally {
                    // Re-enable the button
                    cloneEmotionBtn.disabled = false;
                    cloneEmotionBtn.classList.remove("disabled-button");
                }
            }

            // Helper function to show errors
            function showError(message) {
                const resultContainer = document.getElementById('emotionResultContainer');
                if (resultContainer) {
                    resultContainer.innerHTML = `<p class="text-red-600">${message}</p>`;
                } else {
                    console.error(message);
                    alert(message); // Fallback
                }
            }
        });
        function createProfileCard(profile) {
            const card = document.createElement("div");
            card.className = "bg-white border rounded-lg p-4 shadow-sm hover:shadow-md transition-shadow";
            card.dataset.profileId = profile.id;

            // Format date for display
            let formattedDate = "Unknown date";
            if (profile.created_at) {
                try {
                    const date = new Date(profile.created_at);
                    formattedDate = date.toLocaleDateString();
                } catch (e) {
                    console.error("Error formatting date:", e);
                }
            }

            // Create audio element for the profile
            const audioElement = document.createElement("audio");
            audioElement.controls = true;
            audioElement.className = "w-full mt-2";

            // Set the source for the audio element
            // Make sure the path is correct - this is often a source of issues
            const audioPath = profile.audio_path.startsWith('/')
                ? profile.audio_path
                : `/${profile.audio_path}`;

            // Use the full URL with the correct base path
            audioElement.src = `${API_BASE_URL}/static/${profile.audio_path}`;

            // Create the card content
            card.innerHTML = `
        <div class="flex justify-between items-start">
            <div>
                <h3 class="text-lg font-bold">${profile.voice_name}</h3>
                <p class="text-sm text-gray-600">Language: ${profile.language}</p>
                <p class="text-xs text-gray-500">Created: ${formattedDate}</p>
            </div>
            <div class="flex space-x-1">
                <button class="edit-profile-btn text-blue-500 hover:text-blue-700" title="Edit Profile">
                    <i class="fas fa-edit"></i>
                </button>
                <button class="delete-profile-btn text-red-500 hover:text-red-700" title="Delete Profile">
                    <i class="fas fa-trash-alt"></i>
                </button>
            </div>
        </div>
    `;

            // Append the audio element to the card
            card.appendChild(audioElement);

            // Add event listeners for edit and delete buttons
            const editBtn = card.querySelector(".edit-profile-btn");
            const deleteBtn = card.querySelector(".delete-profile-btn");

            editBtn.addEventListener("click", () => openModalForEdit(profile));
            deleteBtn.addEventListener("click", () => confirmDeleteProfile(profile.id));

            return card;
        }
        function updateSavedVoiceSamplesDropdown(profiles) {
            // Clear existing options first, keeping only the default "Select a saved voice sample" option
            cloneSavedVoiceSampleSelect.innerHTML = '<option value="">Select a saved voice sample</option>';

            // Add each profile as an option in the dropdown
            if (profiles && profiles.length > 0) {
                profiles.forEach(profile => {
                    const option = document.createElement("option");
                    option.value = profile.audio_path;
                    option.textContent = `${profile.voice_name} (${profile.language})`;
                    option.dataset.profileId = profile.id;
                    cloneSavedVoiceSampleSelect.appendChild(option);
                });
            }
        }
    </script>
    <script>
        // Finetuning Tab JavaScript - Wrapped in IIFE to avoid variable conflicts
        (function () {
            // Create a namespace for Finetuning tab
            const FineTuningTab = {
                // DOM Elements - will be initialized when tab is active
                elements: {
                    // Fine-Tuning Section
                    languageSelect: null,
                    projectNameInput: null,
                    uploadBtn: null,
                    recordBtn: null,
                    audioFileInput: null,
                    recordingInterface: null,
                    startStopRecording: null,
                    recordingStatus: null,
                    recordingTime: null,
                    cancelRecording: null,
                    saveRecording: null,
                    audioPreview: null,
                    audioFilename: null,
                    playAudio: null,
                    removeAudio: null,
                    audioPlayer: null,
                    startFineTuningBtn: null,
                    progressContainer: null,
                    progressText: null,
                    progressBar: null,
                    statusContainer: null,
                    errorContainer: null,
                    errorMessage: null,

                    // Synthesis Section
                    synthesisLanguageSelect: null,
                    projectSelect: null,
                    synthesisText: null,
                    synthesisCharCount: null,
                    refUploadBtn: null,
                    refRecordBtn: null,
                    refAudioUpload: null,
                    refRecordingInterface: null,
                    refStartStopRecording: null,
                    refRecordingStatus: null,
                    refRecordingTime: null,
                    refCancelRecording: null,
                    refSaveRecording: null,
                    refAudioPreview: null,
                    refAudioFilename: null,
                    refPlayAudio: null,
                    refRemoveAudio: null,
                    refAudioPlayer: null,
                    startSynthesis: null,
                    synthesisProgressContainer: null,
                    synthesisProgressText: null,
                    synthesisProgressBar: null,
                    synthesisResult: null,
                    synthesisTextPreview: null,
                    playSynthesis: null,
                    downloadSynthesis: null,
                    synthesisPlayer: null
                },

                // State variables
                state: {
                    // Fine-Tuning
                    mediaRecorder: null,
                    audioChunks: [],
                    recordingStartTime: null,
                    recordingTimer: null,
                    isRecording: false,
                    audioBlob: null,
                    audioFile: null,
                    currentProject: null,

                    // Synthesis Reference
                    refMediaRecorder: null,
                    refAudioChunks: [],
                    refRecordingStartTime: null,
                    refRecordingTimer: null,
                    isRefRecording: false,
                    refAudioBlob: null,
                    refAudioFile: null,

                    // Projects
                    allProjects: []
                },

                // Initialize the tab
                init: function () {
                    // Only initialize if the tab is active
                    if (!document.getElementById('fineTuningTabContent')) {
                        console.warn('Finetuning tab content not found in DOM');
                        return;
                    }

                    this.initElements();
                    this.setupEventListeners();

                    // Initialize by fetching projects for the default language
                    if (this.elements.synthesisLanguageSelect) {
                        this.fetchProjectsByLanguage(this.elements.synthesisLanguageSelect.value);
                    }
                },

                // Initialize DOM elements
                initElements: function () {
                    // Fine-Tuning Section
                    this.elements.languageSelect = document.getElementById('fineTuningLanguageSelect');
                    this.elements.projectNameInput = document.getElementById('projectNameInput');
                    this.elements.uploadBtn = document.getElementById('fineTuningUploadBtn');
                    this.elements.recordBtn = document.getElementById('fineTuningRecordBtn');
                    this.elements.audioFileInput = document.getElementById('fineTuningAudioFileInput');
                    this.elements.recordingInterface = document.getElementById('fineTuningRecordingInterface');
                    this.elements.startStopRecording = document.getElementById('fineTuningStartStopRecording');
                    this.elements.recordingStatus = document.getElementById('fineTuningRecordingStatus');
                    this.elements.recordingTime = document.getElementById('fineTuningRecordingTime');
                    this.elements.cancelRecording = document.getElementById('fineTuningCancelRecording');
                    this.elements.saveRecording = document.getElementById('fineTuningSaveRecording');
                    this.elements.audioPreview = document.getElementById('fineTuningAudioPreview');
                    this.elements.audioFilename = document.getElementById('fineTuningAudioFilename');
                    this.elements.playAudio = document.getElementById('fineTuningPlayAudio');
                    this.elements.removeAudio = document.getElementById('fineTuningRemoveAudio');
                    this.elements.audioPlayer = document.getElementById('fineTuningAudioPlayer');
                    this.elements.startFineTuningBtn = document.getElementById('startFineTuningBtn');
                    this.elements.progressContainer = document.getElementById('fineTuningProgressContainer');
                    this.elements.progressText = document.getElementById('fineTuningProgressText');
                    this.elements.progressBar = document.getElementById('fineTuningProgressBar');
                    this.elements.statusContainer = document.getElementById('fineTuningStatusContainer');
                    this.elements.statusContainer = document.getElementById('fineTuningStatusContainer1');
                    
                    this.elements.errorContainer = document.getElementById('fineTuningErrorContainer');
                    this.elements.errorMessage = document.getElementById('fineTuningErrorMessage');
                    this.elements.fineTuningAudioFileInput = document.getElementById("fineTuningAudioFileInput");

                    // Synthesis Section
                    this.elements.synthesisLanguageSelect = document.getElementById('synthesisLanguageSelect');
                    this.elements.projectSelect = document.getElementById('projectSelect');
                    this.elements.synthesisText = document.getElementById('synthesisText');
                    this.elements.synthesisCharCount = document.getElementById('synthesisCharCount');
                    this.elements.refUploadBtn = document.getElementById('refUploadBtn');
                    this.elements.refRecordBtn = document.getElementById('refRecordBtn');
                    this.elements.refAudioUpload = document.getElementById('refAudioUpload');
                    this.elements.refRecordingInterface = document.getElementById('refRecordingInterface');
                    this.elements.refStartStopRecording = document.getElementById('refStartStopRecording');
                    this.elements.refRecordingStatus = document.getElementById('refRecordingStatus');
                    this.elements.refRecordingTime = document.getElementById('refRecordingTime');
                    this.elements.refCancelRecording = document.getElementById('refCancelRecording');
                    this.elements.refSaveRecording = document.getElementById('refSaveRecording');
                    this.elements.refAudioPreview = document.getElementById('refAudioPreview');
                    this.elements.refAudioFilename = document.getElementById('refAudioFilename');
                    this.elements.refPlayAudio = document.getElementById('refPlayAudio');
                    this.elements.refRemoveAudio = document.getElementById('refRemoveAudio');
                    this.elements.refAudioPlayer = document.getElementById('refAudioPlayer');
                    this.elements.startSynthesis = document.getElementById('startSynthesis');
                    this.elements.synthesisProgressContainer = document.getElementById('synthesisProgressContainer');
                    this.elements.synthesisProgressText = document.getElementById('synthesisProgressText');
                    this.elements.synthesisProgressBar = document.getElementById('synthesisProgressBar');
                    this.elements.synthesisResult = document.getElementById('synthesisResult');
                    this.elements.synthesisTextPreview = document.getElementById('synthesisTextPreview');
                    this.elements.playSynthesis = document.getElementById('playSynthesis');
                    this.elements.downloadSynthesis = document.getElementById('downloadSynthesis');
                    this.elements.synthesisPlayer = document.getElementById('synthesisPlayer');

                    // Log any missing elements for debugging
                    for (const key in this.elements) {
                        if (!this.elements[key]) {
                            console.warn(`Finetuning tab element not found: ${key}`);
                        }
                    }
                },

                // Set up event listeners
                setupEventListeners: function () {
                    // Only set up listeners for elements that exist

                    // Synthesis language change
                    if (this.elements.synthesisLanguageSelect) {
                        this.elements.synthesisLanguageSelect.addEventListener('change', () => {
                            this.fetchProjectsByLanguage(this.elements.synthesisLanguageSelect.value);
                        });
                    }

                    // Character counter for synthesis text
                    if (this.elements.synthesisText && this.elements.synthesisCharCount) {
                        this.elements.synthesisText.addEventListener('input', () => {
                            this.elements.synthesisCharCount.textContent = this.elements.synthesisText.value.length;
                        });
                    }

                    // Upload button - Fine-Tuning
                    if (this.elements.uploadBtn && this.elements.audioFileInput) {
                        this.elements.uploadBtn.addEventListener('click', () => {
                            this.elements.audioFileInput.click();
                        });
                    }

                    // File selection - Fine-Tuning
                    if (this.elements.audioFileInput) {
                        this.elements.audioFileInput.addEventListener('change', (e) => {
                            if (e.target.files.length > 0) {
                                this.state.audioFile = e.target.files[0];
                                this.displayAudioPreview(this.state.audioFile.name);
                            }
                        });
                    }

                    // Record button - Fine-Tuning
                    if (this.elements.recordBtn && this.elements.audioPreview && this.elements.recordingInterface) {
                        this.elements.recordBtn.addEventListener('click', () => {
                            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                                // Hide audio preview if visible
                                this.elements.audioPreview.classList.add('hidden');
                                // Show recording interface
                                this.elements.recordingInterface.classList.remove('hidden');
                                fineTuningAudioFileInput.value = "";
                            } else {
                                this.showAlert('Your browser does not support audio recording', 'error');
                            }
                        });
                    }

                    // Start/stop recording - Fine-Tuning
                    if (this.elements.startStopRecording && this.elements.saveRecording) {
                        this.elements.startStopRecording.addEventListener('click', () => {
                            if (!this.state.isRecording) {
                                this.startRecording();
                            } else {
                                this.stopRecording();
                                // Show save recording button immediately
                                this.elements.saveRecording.classList.remove('hidden');
                            }
                        });
                    }

                    // Cancel recording - Fine-Tuning
                    if (this.elements.cancelRecording) {
                        this.elements.cancelRecording.addEventListener('click', () => {
                            if (this.state.isRecording) {
                                this.stopRecording(true); // true = cancel
                            }
                            this.resetRecordingInterface();
                        });
                    }
                    // Save recording - Fine-Tuning
                    if (this.elements.saveRecording) {
                        this.elements.saveRecording.addEventListener('click', () => {
                            if (this.state.audioBlob) {
                                const now = new Date();
                                const filename = `recording_${now.getFullYear()}${this.padZero(now.getMonth() + 1)}${this.padZero(now.getDate())}_${this.padZero(now.getHours())}${this.padZero(now.getMinutes())}${this.padZero(now.getSeconds())}.webm`;
                                this.state.audioFile = new File([this.state.audioBlob], filename, { type: 'audio/webm' });
                                this.displayAudioPreview(filename);
                                this.resetRecordingInterface();
                            } else {
                                this.showAlert("No audio recording available to save", "error");
                            }
                        });
                    }

                    // Play audio - Fine-Tuning
                    if (this.elements.playAudio && this.elements.audioPlayer) {
                        this.elements.playAudio.addEventListener('click', () => {
                            if (this.elements.audioPlayer.src) {
                                if (this.elements.audioPlayer.paused) {
                                    this.elements.audioPlayer.play();
                                    this.elements.playAudio.innerHTML = '<i class="fas fa-pause"></i>';
                                } else {
                                    this.elements.audioPlayer.pause();
                                    this.elements.playAudio.innerHTML = '<i class="fas fa-play"></i>';
                                }
                            }
                        });
                    }

                    // Remove audio - Fine-Tuning
                    if (this.elements.removeAudio && this.elements.audioPlayer && this.elements.audioPreview) {
                        this.elements.removeAudio.addEventListener('click', () => {
                            this.state.audioFile = null;
                            this.state.audioBlob = null;
                            this.elements.audioPreview.classList.add('hidden');
                            // this.elements.audioPlayer.src = '';
                            this.elements.fineTuningAudioFileInput.value = ''; // Clear the file input
                        });
                    }

                    // Audio player ended - Fine-Tuning
                    if (this.elements.audioPlayer && this.elements.playAudio) {
                        this.elements.audioPlayer.addEventListener('ended', () => {
                            this.elements.playAudio.innerHTML = '<i class="fas fa-play"></i>';
                        });
                    }

                    // Reference upload button
                    if (this.elements.refUploadBtn && this.elements.refAudioUpload) {
                        this.elements.refUploadBtn.addEventListener('click', () => {
                            // debugger;
                            this.elements.refAudioUpload.click();
                        });
                    }

                    // Reference file selection
                    if (this.elements.refAudioUpload) {
                        this.elements.refAudioUpload.addEventListener('change', (e) => {
                            if (e.target.files.length > 0) {
                                this.state.refAudioFile = e.target.files[0];
                                this.displayRefAudioPreview(this.state.refAudioFile.name);
                            }
                        });
                    }

                    // Reference record button
                    if (this.elements.refRecordBtn && this.elements.refAudioPreview && this.elements.refRecordingInterface) {
                        this.elements.refRecordBtn.addEventListener('click', () => {
                            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                                // Hide audio preview if visible
                                this.elements.refAudioPreview.classList.add('hidden');
                                // Show recording interface
                                this.elements.refRecordingInterface.classList.remove('hidden');
                            } else {
                                this.showAlert('Your browser does not support audio recording', 'error');
                            }
                        });
                    }

                    // Reference start/stop recording
                    if (this.elements.refStartStopRecording && this.elements.refSaveRecording) {
                        this.elements.refStartStopRecording.addEventListener('click', () => {
                            if (!this.state.isRefRecording) {
                                this.startRefRecording();
                            } else {
                                this.stopRefRecording();
                                // Show save recording button immediately
                                this.elements.refSaveRecording.classList.remove('hidden');
                            }
                        });
                    }

                    // Reference cancel recording
                    if (this.elements.refCancelRecording) {
                        this.elements.refCancelRecording.addEventListener('click', () => {
                            if (this.state.isRefRecording) {
                                this.stopRefRecording(true); // true = cancel
                            }
                            this.resetRefRecordingInterface();
                        });
                    }

                    // Reference save recording
                    if (this.elements.refSaveRecording) {
                        this.elements.refSaveRecording.addEventListener('click', () => {
                            if (this.state.refAudioBlob) {
                                const now = new Date();
                                const filename = `ref_recording_${now.getFullYear()}${this.padZero(now.getMonth() + 1)}${this.padZero(now.getDate())}_${this.padZero(now.getHours())}${this.padZero(now.getMinutes())}${this.padZero(now.getSeconds())}.webm`;
                                this.state.refAudioFile = new File([this.state.refAudioBlob], filename, { type: 'audio/webm' });
                                this.displayRefAudioPreview(filename);
                                this.resetRefRecordingInterface();
                            } else {
                                this.showAlert("No reference audio recording available to save", "error");
                            }
                        });
                    }

                    // Play reference audio
                    if (this.elements.refPlayAudio && this.elements.refAudioPlayer) {
                        this.elements.refPlayAudio.addEventListener('click', () => {
                            if (this.elements.refAudioPlayer.src) {
                                if (this.elements.refAudioPlayer.paused) {
                                    this.elements.refAudioPlayer.play();
                                    this.elements.refPlayAudio.innerHTML = '<i class="fas fa-pause"></i>';
                                } else {
                                    this.elements.refAudioPlayer.pause();
                                    this.elements.refPlayAudio.innerHTML = '<i class="fas fa-play"></i>';
                                }
                            }
                        });
                    }

                    // Remove reference audio
                    if (this.elements.refRemoveAudio && this.elements.refAudioPlayer && this.elements.refAudioPreview) {
                        this.elements.refRemoveAudio.addEventListener('click', () => {
                            this.state.refAudioFile = null;
                            this.state.refAudioBlob = null;
                            this.elements.refAudioPreview.classList.add('hidden');
                            this.elements.refAudioPlayer.src = '';
                        });
                    }

                    // Reference audio player ended
                    if (this.elements.refAudioPlayer && this.elements.refPlayAudio) {
                        this.elements.refAudioPlayer.addEventListener('ended', () => {
                            this.elements.refPlayAudio.innerHTML = '<i class="fas fa-play"></i>';
                        });
                    }

                    // Start Fine-Tuning button
                    if (this.elements.startFineTuningBtn) {
                        this.elements.startFineTuningBtn.addEventListener('click', async () => {
                            await this.startFineTuning();
                        });
                    }

                    // Start Synthesis button
                    if (this.elements.startSynthesis) {
                        this.elements.startSynthesis.addEventListener('click', async () => {
                            await this.startSynthesis();
                        });
                    }

                    // Play synthesis button
                    if (this.elements.playSynthesis && this.elements.synthesisPlayer) {
                        this.elements.playSynthesis.addEventListener('click', () => {
                            if (this.elements.synthesisPlayer.paused) {
                                this.elements.synthesisPlayer.play();
                                this.elements.playSynthesis.innerHTML = '<i class="fas fa-pause mr-2"></i> Pause';
                            } else {
                                this.elements.synthesisPlayer.pause();
                                this.elements.playSynthesis.innerHTML = '<i class="fas fa-play mr-2"></i> Play';
                            }
                        });
                    }

                    // Synthesis player ended
                    if (this.elements.synthesisPlayer && this.elements.playSynthesis) {
                        this.elements.synthesisPlayer.addEventListener('ended', () => {
                            this.elements.playSynthesis.innerHTML = '<i class="fas fa-play mr-2"></i> Play';
                        });
                    }
                },

                // Fetch projects by language
                fetchProjectsByLanguage: async function (language) {
                    try {
                        this.showProgress('Fetching projects...', 50);

                        // Call the API to get projects for the selected language
                        const response = await fetch(`/api/get-projects?language=${language}`);

                        if (!response.ok) {
                            throw new Error(`Failed to fetch projects: ${response.statusText}`);
                        }

                        const data = await response.json();

                        // Update the projects dropdown
                        this.updateProjectsDropdown(data.projects, language);

                        this.hideProgress();
                    } catch (error) {
                        this.hideProgress();
                        this.showAlert(`Error fetching projects: ${error.message}`, 'error');
                    }
                },

                // Update projects dropdown
                updateProjectsDropdown: function (projects, language) {
                    if (!this.elements.projectSelect) return;

                    // Clear existing options except the default one
                    while (this.elements.projectSelect.options.length > 1) {
                        this.elements.projectSelect.remove(1);
                    }

                    // Filter projects by language if they have a prefix
                    const filteredProjects = projects.filter(project => {
                        if (project.includes(':')) {
                            const projectLanguage = project.split(':')[0];
                            return projectLanguage.toLowerCase() === language.toLowerCase();
                        }
                        // If no prefix, include in both (backward compatibility)
                        return true;
                    });

                    // Add filtered projects to dropdown
                    filteredProjects.forEach(project => {
                        const option = document.createElement('option');
                        option.value = project;

                        // Display name without language prefix if it exists
                        if (project.includes(':')) {
                            option.textContent = project.split(':')[1];
                        } else {
                            option.textContent = project;
                        }

                        this.elements.projectSelect.appendChild(option);
                    });

                    // Store all projects for future filtering
                    this.state.allProjects = projects;
                },

                // Start recording for fine-tuning
                startRecording: function () {
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then(stream => {
                            this.state.mediaRecorder = new MediaRecorder(stream);
                            this.state.audioChunks = [];

                            this.state.mediaRecorder.addEventListener('dataavailable', event => {
                                this.state.audioChunks.push(event.data);
                            });

                            this.state.mediaRecorder.addEventListener('stop', () => {
                                if (this.state.audioChunks.length > 0) {
                                    this.state.audioBlob = new Blob(this.state.audioChunks, { type: 'audio/webm' });
                                    this.state.audioChunks = [];
                                }
                            });

                            this.state.mediaRecorder.start();
                            this.state.isRecording = true;
                            this.elements.recordingStatus.textContent = 'Recording...';
                            this.elements.startStopRecording.innerHTML = '<i class="fas fa-stop"></i>';

                            // Start timer
                            this.state.recordingStartTime = Date.now();
                            this.updateRecordingTime();
                            this.state.recordingTimer = setInterval(() => this.updateRecordingTime(), 1000);
                        })
                        .catch(error => {
                            this.showAlert(`Error accessing microphone: ${error.message}`, 'error');
                        });
                },

                // Stop recording for fine-tuning
                stopRecording: function (cancel = false) {
                    if (this.state.mediaRecorder && this.state.isRecording) {
                        this.state.mediaRecorder.stop();
                        this.state.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                        this.state.isRecording = false;

                        // Stop timer
                        clearInterval(this.state.recordingTimer);

                        this.elements.recordingStatus.textContent = 'Recording stopped';
                        this.elements.startStopRecording.innerHTML = '<i class="fas fa-microphone"></i>';

                        if (!cancel && this.elements.saveRecording) {
                            this.elements.saveRecording.classList.remove('hidden');
                        }
                    }
                },

                // Update recording time display for fine-tuning
                updateRecordingTime: function () {
                    if (!this.elements.recordingTime) return;

                    const elapsed = Math.floor((Date.now() - this.state.recordingStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    this.elements.recordingTime.textContent = `${this.padZero(minutes)}:${this.padZero(seconds)}`;
                },

                // Reset recording interface for fine-tuning
                resetRecordingInterface: function () {
                    if (!this.elements.recordingInterface) return;

                    this.elements.recordingInterface.classList.add('hidden');
                    if (this.elements.recordingStatus) {
                        this.elements.recordingStatus.textContent = 'Click to start recording';
                    }
                    if (this.elements.startStopRecording) {
                        this.elements.startStopRecording.innerHTML = '<i class="fas fa-microphone"></i>';
                    }
                    if (this.elements.recordingTime) {
                        this.elements.recordingTime.textContent = '00:00';
                    }
                    if (this.elements.saveRecording) {
                        this.elements.saveRecording.classList.add('hidden');
                    }
                },

                // Display audio preview for fine-tuning
                displayAudioPreview: function (filename) {
                    if (!this.elements.audioFilename || !this.elements.audioPreview || !this.elements.audioPlayer) return;

                    this.elements.audioFilename.textContent = filename;
                    this.elements.audioPreview.classList.remove('hidden');

                    if (this.state.audioBlob) {
                        this.elements.audioPlayer.src = URL.createObjectURL(this.state.audioBlob);
                    } else if (this.state.audioFile) {
                        this.elements.audioPlayer.src = URL.createObjectURL(this.state.audioFile);
                    }
                },

                // Start recording for reference
                startRefRecording: function () {
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then(stream => {
                            this.state.refMediaRecorder = new MediaRecorder(stream);
                            this.state.refAudioChunks = [];

                            this.state.refMediaRecorder.addEventListener('dataavailable', event => {
                                this.state.refAudioChunks.push(event.data);
                            });

                            this.state.refMediaRecorder.addEventListener('stop', () => {
                                if (this.state.refAudioChunks.length > 0) {
                                    this.state.refAudioBlob = new Blob(this.state.refAudioChunks, { type: 'audio/webm' });
                                    this.state.refAudioChunks = [];
                                }
                            });

                            this.state.refMediaRecorder.start();
                            this.state.isRefRecording = true;
                            this.elements.refRecordingStatus.textContent = 'Recording...';
                            this.elements.refStartStopRecording.innerHTML = '<i class="fas fa-stop"></i>';

                            // Start timer
                            this.state.refRecordingStartTime = Date.now();
                            this.updateRefRecordingTime();
                            this.state.refRecordingTimer = setInterval(() => this.updateRefRecordingTime(), 1000);
                        })
                        .catch(error => {
                            this.showAlert(`Error accessing microphone: ${error.message}`, 'error');
                        });
                },

                // Stop recording for reference
                stopRefRecording: function (cancel = false) {
                    if (this.state.refMediaRecorder && this.state.isRefRecording) {
                        this.state.refMediaRecorder.stop();
                        this.state.refMediaRecorder.stream.getTracks().forEach(track => track.stop());
                        this.state.isRefRecording = false;

                        // Stop timer
                        clearInterval(this.state.refRecordingTimer);

                        this.elements.refRecordingStatus.textContent = 'Recording stopped';
                        this.elements.refStartStopRecording.innerHTML = '<i class="fas fa-microphone"></i>';

                        if (!cancel && this.elements.refSaveRecording) {
                            this.elements.refSaveRecording.classList.remove('hidden');
                        }
                    }
                },

                // Update recording time display for reference
                updateRefRecordingTime: function () {
                    if (!this.elements.refRecordingTime) return;

                    const elapsed = Math.floor((Date.now() - this.state.refRecordingStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    this.elements.refRecordingTime.textContent = `${this.padZero(minutes)}:${this.padZero(seconds)}`;
                },

                // Reset recording interface for reference
                resetRefRecordingInterface: function () {
                    if (!this.elements.refRecordingInterface) return;

                    this.elements.refRecordingInterface.classList.add('hidden');
                    if (this.elements.refRecordingStatus) {
                        this.elements.refRecordingStatus.textContent = 'Click to start recording';
                    }
                    if (this.elements.refStartStopRecording) {
                        this.elements.refStartStopRecording.innerHTML = '<i class="fas fa-microphone"></i>';
                    }
                    if (this.elements.refRecordingTime) {
                        this.elements.refRecordingTime.textContent = '00:00';
                    }
                    if (this.elements.refSaveRecording) {
                        this.elements.refSaveRecording.classList.add('hidden');
                    }
                },

                // Display audio preview for reference
                displayRefAudioPreview: function (filename) {
                    if (!this.elements.refAudioFilename || !this.elements.refAudioPreview || !this.elements.refAudioPlayer) return;

                    this.elements.refAudioFilename.textContent = filename;
                    this.elements.refAudioPreview.classList.remove('hidden');

                    if (this.state.refAudioBlob) {
                        this.elements.refAudioPlayer.src = URL.createObjectURL(this.state.refAudioBlob);
                    } else if (this.state.refAudioFile) {
                        this.elements.refAudioPlayer.src = URL.createObjectURL(this.state.refAudioFile);
                    }
                },

                // Start fine-tuning process
                startFineTuning: async function () {
                    try {
                        // Validate inputs
                        if (!this.elements.projectNameInput.value.trim()) {
                            this.showAlert('Please enter a project name', 'error');
                            return;
                        }

                        if (!this.state.audioFile) {
                            this.showAlert('Please upload or record an audio sample', 'error');
                            return;
                        }

                        // Create FormData for the API request
                        const formData = new FormData();
                        formData.append('project_name', this.elements.projectNameInput.value.trim());
                        formData.append('language', this.elements.languageSelect.value);
                        formData.append('audio_file', this.state.audioFile);

                        // Show progress indicator
                        this.showProgress('Creating project...', 10);

                        // Step 1: Create the project
                        const createProjectResponse = await fetch('/api/projects', {
                            method: 'POST',
                            body: formData
                        });

                        if (!createProjectResponse.ok) {
                            const errorData = await createProjectResponse.json();
                            throw new Error(errorData.message || 'Failed to create project');
                        }

                        const projectData = await createProjectResponse.json();
                        this.state.currentProject = projectData.project_name;

                        // Update progress
                        this.showProgress('Uploading and transcribing audio...', 30);

                        // Step 2: Upload and transcribe the audio
                        const uploadFormData = new FormData();
                        uploadFormData.append('project_name', this.state.currentProject);
                        uploadFormData.append('language', this.elements.languageSelect.value);
                        uploadFormData.append('audio_file', this.state.audioFile);

                        const uploadResponse = await fetch('/api/upload', {
                            method: 'POST',
                            body: uploadFormData
                        });

                        if (!uploadResponse.ok) {
                            const errorData = await uploadResponse.json();
                            throw new Error(errorData.message || 'Failed to upload audio');
                        }

                        // Update progress
                        this.showProgress('Starting fine-tuning process...', 50);

                        // Step 3: Start the training process
                        const trainingFormData = new FormData();
                        trainingFormData.append('project_name', this.state.currentProject);
                        trainingFormData.append('language', this.elements.languageSelect.value);

                        const trainingResponse = await fetch('/api/start-training', {
                            method: 'POST',
                            body: trainingFormData
                        });

                        if (!trainingResponse.ok) {
                            const errorData = await trainingResponse.json();
                            throw new Error(errorData.message || 'Failed to start training');
                        }

                        const trainingData = await trainingResponse.json();

                        // Update progress to indicate training is in progress
                        this.showProgress('Fine-tuning in progress...', 70);

                        // Show success message
                        this.showAlert('Fine-tuning process started successfully! This may take several minutes to complete.', 'success');

                        // Refresh the projects list after a delay
                        setTimeout(() => {
                            this.fetchProjectsByLanguage(this.elements.synthesisLanguageSelect.value);
                        }, 5000);

                    } catch (error) {
                        this.hideProgress();
                        this.showAlert(`Error: ${error.message}`, 'error');
                    }
                },

                // Start synthesis process
                startSynthesis: async function () {
                    try {
                        // Validate inputs
                        if (!this.elements.projectSelect.value) {
                            this.showAlert('Please select a project', 'error');
                            return;
                        }

                        if (!this.elements.synthesisText.value.trim()) {
                            this.showAlert('Please enter text to synthesize', 'error');
                            return;
                        }

                        // Create FormData for the API request
                        const formData = new FormData();
                        // IMPORTANT: Add this code to clean the project name
                        let projectName = this.elements.projectSelect.value;
                        // Remove any language prefix (like "spanish:") from the project name
                        projectName = projectName.replace(/^[^:]+:/, '');

                        // Use the cleaned project name in the form data
                        formData.append('project_name', projectName);


                        formData.append('language', this.elements.synthesisLanguageSelect.value);
                        formData.append('text', this.elements.synthesisText.value.trim());

                        // Add reference audio if available
                        if (this.state.refAudioFile) {
                            formData.append('reference_audio', this.state.refAudioFile);
                        }

                        // Show progress indicator
                        this.showSynthesisProgress('Synthesizing speech...', 30);

                        // Call the synthesis API
                        const response = await fetch('/api/synthesize', {
                            method: 'POST',
                            body: formData
                        });

                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(errorData.message || 'Failed to synthesize speech');
                        }

                        // Get the audio blob from the response
                        const audioBlob = await response.blob();

                        // Update progress
                        this.showSynthesisProgress('Processing complete!', 100);

                        // Display the result
                        this.elements.synthesisTextPreview.textContent = this.elements.synthesisText.value.trim();
                        this.elements.synthesisPlayer.src = URL.createObjectURL(audioBlob);
                        this.elements.synthesisResult.classList.remove('hidden');

                        // Set up download button
                        this.elements.downloadSynthesis.onclick = () => {
                            const a = document.createElement('a');
                            a.href = this.elements.synthesisPlayer.src;
                            a.download = `synthesis_${Date.now()}.wav`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                        };

                        // Hide progress after a delay
                        setTimeout(() => {
                            this.hideSynthesisProgress();
                        }, 1000);

                    } catch (error) {
                        this.hideSynthesisProgress();
                        this.showAlert(`Error: ${error.message}`, 'error');
                    }
                },

                // Show progress indicator for fine-tuning
                showProgress: function (message, percent) {
                    if (!this.elements.progressText || !this.elements.progressBar || !this.elements.progressContainer) return;

                    this.elements.progressText.textContent = message;
                    this.elements.progressBar.style.width = `${percent}%`;
                    this.elements.progressContainer.classList.remove('hidden');
                },

                // Hide progress indicator for fine-tuning
                hideProgress: function () {
                    if (this.elements.progressContainer) {
                        this.elements.progressContainer.classList.add('hidden');
                    }
                },

                // Show progress indicator for synthesis
                showSynthesisProgress: function (message, percent) {
                    if (!this.elements.synthesisProgressText || !this.elements.synthesisProgressBar || !this.elements.synthesisProgressContainer) return;

                    this.elements.synthesisProgressText.textContent = message;
                    this.elements.synthesisProgressBar.style.width = `${percent}%`;
                    this.elements.synthesisProgressContainer.classList.remove('hidden');
                },

                // Hide progress indicator for synthesis
                hideSynthesisProgress: function () {
                    if (this.elements.synthesisProgressContainer) {
                        this.elements.synthesisProgressContainer.classList.add('hidden');
                    }
                },

                // Show alert message
               // Show flash alert message
showAlert: function(message, type = 'success') {
    const container = document.getElementById('fineTuningStatusContainer1');
    if (!container) return;

    // Clear previous alerts
    container.innerHTML = '';

    // Create alert element
    const alertElement = document.createElement('div');
    alertElement.className = type === 'error'
        ? 'bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded shadow-md mb-4 relative transition-opacity duration-300'
        : 'bg-green-100 border-l-4 border-green-500 text-green-700 p-4 rounded shadow-md mb-4 relative transition-opacity duration-300';

    alertElement.textContent = message;

    // Add close button
    const closeButton = document.createElement('button');
    closeButton.className = 'absolute top-2 right-2 text-gray-500 hover:text-gray-700';
    closeButton.innerHTML = '&times;';
    closeButton.onclick = () => {
        alertElement.style.opacity = 0;
        setTimeout(() => alertElement.remove(), 300);
    };

    alertElement.appendChild(closeButton);

    // Add to container
    container.appendChild(alertElement);

    // Auto-remove success/error messages after 5 seconds
    setTimeout(() => {
        alertElement.style.opacity = 0;
        setTimeout(() => alertElement.remove(), 300);
    }, 5000);
},

                // Pad zero for time display
                padZero: function (num) {
                    return num.toString().padStart(2, '0');
                }
            };

            // Initialize when the tab is activated
            document.addEventListener('DOMContentLoaded', function () {
                // Check if we're on the Finetuning tab
                const fineTuningTabBtn = document.getElementById('fineTuningTabBtn');
                const fineTuningTabContent = document.getElementById('fineTuningTabContent');

                if (fineTuningTabBtn && fineTuningTabContent) {
                    // Initialize when the tab is clicked
                    fineTuningTabBtn.addEventListener('click', function () {
                        // Only initialize if not already initialized
                        if (!FineTuningTab.initialized) {
                            FineTuningTab.init();
                            FineTuningTab.initialized = true;
                        }
                    });

                    // Also initialize if the tab is already active on page load
                    if (!fineTuningTabContent.classList.contains('hidden')) {
                        FineTuningTab.init();
                        FineTuningTab.initialized = true;
                    }
                }
            });
        })();
    </script>

<!-- Bootstrap Toast Container -->
<div aria-live="polite" aria-atomic="true" class="position-relative">
  <div id="toastContainer" class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 9999;"></div>
</div>


<script>
function showToast(message, type = 'info') {
    const toastId = 'toast' + Date.now();
    const toastHtml = `
        <div id="${toastId}" class="toast align-items-center text-bg-${type} border-0 show mb-2" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">
                    ${message}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        </div>
    `;
    const container = document.getElementById('toastContainer');
    container.insertAdjacentHTML('beforeend', toastHtml);
    const toastEl = document.getElementById(toastId);
    const toast = new bootstrap.Toast(toastEl, { delay: 5000 });
    toast.show();
    toastEl.addEventListener('hidden.bs.toast', () => toastEl.remove());
}
</script>

</body>

</html>
